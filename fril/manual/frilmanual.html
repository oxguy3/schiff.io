<html><head><title>Fril : Built-in predicates</title><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><script language="JavaScript"><!--function MM_popupMsg(msg) { //v1.0  alert(msg);}//--></script></head><body bgcolor="#FFFFFF"><h2>Fril : Built-in predicates</h2><p>Prelminary online documentation for Fril appears in this window. Use the index   on the left to select the built-in predicate; future releases will include searching   by category, trace, errors, module compiler, FAQS, and all that good stuff.   . . </p><h2>All material &copy; Fril Systems Ltd 1999</h2><hr><a name = "bip!"> </a><h2>!  </h2><h3>Usage</h3><p> (!) <br></p><h3>Description</h3><p> "!", the cut, is used to alter the normal Fril execution strategy by removing alternative clauses. In an ordinary query, using the depth-first execution strategy, the cut removes all backtrack points between itself and the head of the clause in which it appears. When used in a support query, the cut removes alternatives, unless a goal preceding it in the clause has been proved false, i.e. has support (0 0).</p><h3> Behaviour </h3><p>Succeeds on first call, not resatisfiable.</p><h3>Example </h3><pre>((test a) (!))<br>((test b))<br>?((test a))<br>% yes<br>?((test b))<br>% yes<br>?((test X) (p 'X = ' X) (pp) (fail))<br>X = a<br>% no</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bip?"> ? </a>, <a href="frilmanual.html#bipsnips">snips</a><hr> <a name = "bip?"> </a><h2>?  </h2><h3>Usage</h3><p> (? <a href="glossary.html#goal_list" target="gloss">goal_list</a>) <br></p><h3>Description</h3><p> "?" executes the series of calls in <a href="glossary.html#goal_list" target="gloss" >goal_list</a>,   using the standard depth-first search mechanism. "?" can be nested within calls   to "?" or other built-in predicates that take goals or goal lists as arguments,   e.g. neg, negg, orr, supp_query. Note that "?" appearing within a "supp_query"   causes the search mechanism to change from breadth to depth-first until the   "?" is satisfied.</p><h3> Behaviour </h3><p>Succeeds when a solution to <a href="glossary.html#goal_list" target="gloss">goal_list</a> has been found. Fails if no solution is found. "?" itself is not resatisfiable, although one or more goals in <a href="glossary.html#goal_list" target="gloss">goal_list</a> may be resatisfied.</p><h3>Example </h3><pre>((word1 hello))<br>((word2 world))<br>?((word1 X) (word2 Y) (p X Y) (pp))<br>% hello world<br>% yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipoh">oh</a>, <a href="frilmanual.html#bipqh">qh</a>, <a href="frilmanual.html#bipwh">wh</a>, <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipsnips">snips</a>, <a href="frilmanual.html#biprepeat">repeat</a>, <a href="frilmanual.html#bipfail">fail</a><hr> <a name = "bipabort"> </a><h2>abort  </h2><h3>Usage</h3><p> (abort) <br></p><h3>Description</h3><p> "abort" terminates execution of the current goal, and resets the system to Fril top level. All output buffers are flushed, "errm" and "err_han" are reset, and any open streams are closed.</p><h3> Behaviour </h3><p>Always succeeds.</p><h3>Example </h3><pre>((test X)<br>	(negg con X)<br>	(p X is not a constant)<br>	(abort))<br>test 12<br>12 is not a constant<br>system reset</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipexit">exit</a>, <a href="frilmanual.html#bipfail">fail</a>, <a href="frilmanual.html#biperr_han">err_han</a><hr> <a name = "bipaddcl"> </a><h2>addcl  </h2><h3>Usage</h3><p> (addcl <a href="glossary.html#clause" target="gloss">&lt;clause&gt;</a>) <br>(addcl <a href="glossary.html#clause" target="gloss">&lt;clause&gt;</a> : <a href="glossary.html#cl_supp" target="gloss">&lt;cl_supp&gt;</a>)<br>(addcl <a href="glossary.html#clause" target="gloss">&lt;clause&gt;</a> <a href="glossary.html#int" target="gloss">&lt;int&gt;</a>)<br>(addcl <a href="glossary.html#clause" target="gloss">&lt;clause&gt;</a> : <a href="glossary.html#cl_supp" target="gloss">&lt;cl_supp&gt;</a> <a href="glossary.html#int" target="gloss">&lt;int&gt;</a>)</p><h3>Description</h3><p> "addcl" adds <a href="glossary.html#clause" target="gloss">&lt;clause&gt;</a> to the knowledge base, with support <a href="glossary.html#cl_supp" target="gloss">&lt;cl_supp&gt;</a> if given. By default, <a href="glossary.html#clause" target="gloss">&lt;clause&gt;</a> is added after any other definitions for the same predicate. Exceptions to the default are as follows:<br>(i) If the predicate names a clause set, then the third and fourth forms of addcl allow clauses to be added after the <a href="glossary.html#int" target="gloss">&lt;int&gt;</a>'th existing clause. For instance, a value of 0 for <a href="glossary.html#int" target="gloss">&lt;int&gt;</a> would make <a href="glossary.html#clause" target="gloss">&lt;clause&gt;</a> the first entry in the clause set for the predicate. If <a href="glossary.html#int" target="gloss">&lt;int&gt;</a> is less than zero or greater than the number of clauses in the definition, then the new clause is added before the first or after the last existing clause, respectively.<br>(ii) If the predicate names a relation, then the clause (which must be a fact) is added as a tuple to the relation. Since tuples of a relation are held in an internally determined form, the <a href="glossary.html#int" target="gloss">&lt;int&gt;</a> in the third or fourth form of addcl is ignored.</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#clause" target="gloss">&lt;clause&gt;</a> and <a href="glossary.html#cl_supp" target="gloss">&lt;cl_supp&gt;</a> are valid, and <a href="glossary.html#clause" target="gloss">&lt;clause&gt;</a> can be added to the existing definition (if any).</p><h3>Example </h3><pre>?((addcl ((append (H|T) L (H|R)) (append T L R))))<br>% adds a clause to the definition of append.<br>?((addcl ((append () L L))  0))<br>% adds a second clause to the start of the definition.</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipdelcl">delcl</a>, <a href="frilmanual.html#bipkill">kill</a>, <a href="frilmanual.html#bipdef_rel">def_rel</a>, menu, <a href="frilmanual.html#bipdempster">dempster</a>, <a href="frilmanual.html#bipcl">cl</a>, <a href="frilmanual.html#bipload">load</a><h3>Notes</h3> <p> Adding clauses during execution of a program can lead to unpredictable behaviour - for instance if backtrack points have been set up in a procedure, and a clause is added to the procedure, Fril may or may not pick up the new clause on backtracking, e.g. if the knowledge base contains:<br>((pred a))<br>((pred c))<br>then the query<br>?((pred X) (addcl ((pred b)) 1) (pp X) (fail))<br>would give X = a and X = c as solutions, because the address of clause ((pred c)) would be stored as the next solution before the extra clause was added. On the other hand,<br>?((pred X) (addcl ((pred b))) (pp X) (fail))<br>would give X = a, X = c and X = b as solutions. A fresh call to pred will pick up any added definitions.</p><hr> <a name = "bipand"> </a><h2>and  </h2><h3>Usage</h3><p> (and <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> ... <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a>) <br></p><h3>Description</h3><p> "and" implements the default Fril support logic conjunction. It accumulates the support for successive pairs of the support logic goals <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> to <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a> combining them using the default support logic calculus for conjunction.</p><h3> Behaviour </h3><p>"and" always succeeds when it is being used within queries evaluating supports. The support for the goal <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> is combined with the support for <a href="glossary.html#goal" target="gloss">&lt;goal2&gt;</a> using the default product calculus for conjunction. The combined support is then further combined with the support for <a href="glossary.html#goal" target="gloss">&lt;goal3&gt;</a> and so on in recursive fashion.</p><h3>Example </h3><pre>?((supp_query ((econ X)(safe X)(rel X)) S) (p X S) (pp))<br>and<br>?((supp_query ((and (econ X) (safe X) (rel X))) S) (p X S) (pp))<br>have a similar meaning and effect.<br>The following example shows the advantage of the notation for default support logic conjunction using "and":<br>((suplog_expr X Y)<br>	(or (economy X Y)<br>	(and (safety X Y) (reliability X Y)))) : (1 1)</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipor">or</a>, <a href="frilmanual.html#bipconj">conj</a>, <a href="frilmanual.html#bipdisj">disj</a>, <a href="frilmanual.html#bipnot">not</a>, <a href="frilmanual.html#bipsupp_query">supp_query</a><h3>Notes</h3> <p> This predicate is not normally required, since the basic support logic mechanism uses the default calculus when computing support for a conjunction of goals expressed as a list. However, the predicate is included for completeness, so that the pairing of "and" and "or" can be compared with their counterparts "conj" and "disj" respectively. The fact that a conjunction of goals can be expressed as a single goal using "and" is occasionally very useful.</p><hr> <a name = "bipatomic"> </a><h2>atomic  </h2><h3>Usage</h3><p> (atomic <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>) <br></p><h3>Description</h3><p> "atomic" tests whether its argument is a constant or a number.</p><h3> Behaviour </h3><p>"atomic" succeeds when its argument is a constant or a number, and fails otherwise.</p><h3>Example </h3><pre>atomic 42<br>yes<br>With the fuzzy set definition<br>(myfuzzy [0:1, 1:0]) <br>the following calls succeed:<br>atomic Bruce<br>atomic 'one string'<br>atomic "another string"<br>atomic 42<br>atomic 42.0<br>atomic 42.3<br>and the following calls fail:<br>atomic myfuzzy<br>atomic 'myfuzzy'<br>atomic EXotic</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipcon">con</a>, <a href="frilmanual.html#bipnum">num</a>, <a href="frilmanual.html#bipvar">var</a>, <a href="frilmanual.html#bipuniv">univ</a>, <a href="frilmanual.html#bipitype">itype</a>, <a href="frilmanual.html#bipint">int</a>, <a href="frilmanual.html#bipfset">fset</a>, <a href="frilmanual.html#bipdtype">dtype</a><h3>Notes</h3> <p> If <a href="glossary.html#const">&lt;const&gt;</a> is the name of a fuzzy set (i.e. an itype or dtype definition), then (atomic <a href="glossary.html#const">&lt;const&gt;</a>) will fail. Any quoted string (other than a fuzzy set name) is a constant.</p><hr> <a name = "bipcd"> </a><h2>cd  </h2><h3>Usage</h3><p> (cd <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>)  <br>(cd <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>)</p><h3>Description</h3><p> cd reports the current directory in <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>, or changes it to the directory specified by <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>. <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> may be a relative or full directory pathname, and if any special characters such as '\' are included, then the whole directory specification must be formulated as a string by enclosing it in quotation marks.</p><h3> Behaviour </h3><p>Second form with <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> always succeeds. The first form succeeds if the call <br>"cd <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>" <br>is a legal directory change, otherwise it fails.</p><h3>Example </h3><pre>qh((cd X)) <br>% reports the current directory.<br>cd ‘..’<br>% on a Unix or Windows system changes to the directory containing the current directory;<br>cd ‘::’ <br>% has the same effect on a Mac<br>?((cd D) (filename D PAR DIR '') (cd PAR))<br>% will always change to the directory containing the current directory (assuming one exists).</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipexists">exists</a>, <a href="frilmanual.html#bipgetenv">getenv</a>, <a href="frilmanual.html#bipsetenv">setenv</a>, <a href="frilmanual.html#bipfilename">filename</a>, get_directory<h3>Cross-platform compatibility</h3> <p> Because of differences in file and directory naming conventions, it is difficult to write transportable code which uses "cd" to set the directory, e.g. to change to a directory "mydir" in the directory above the current directory, one would use <br>cd ‘::mydir’<br>cd ‘../mydir’<br>cd ‘..\mydir’<br>on (respectively) a Mac, Unix, and MSDOS platform. The built-in predicate "filename" may be helpful in writing transportable code using "cd".</p><hr> <a name = "bipcdict"> </a><h2>cdict  </h2><h3>Usage</h3><p> (cdict <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>) <br></p><h3>Description</h3><p> cdict checks whether <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> names a clause set in the knowledge base. If <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a variable, cdict binds it to the name of a clause set, assuming at least one clause has been defined. Different predicates can be generated by backtracking to cdict. Dempster, menu, and dialog definitions are not included.</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> can be unified with the predicate of a clause in the knowledge base. If <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a variable, cdict is resatisfiable. If <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is not a predicate name, or there are no clauses defined, cdict fails. </p><h3>Example </h3><pre>(fuey [2:0, 5:0.7, 8:1])<br>dempster ploy<br>((ploy X) (skye X)) : (0.8 1)<br>((ploy X) (nomore X)) : (1 1)<br>(loro (span) (raul) ... )<br>((skye X) ... )<br>((nomore X) ... )<br><br>?((member X (fuey ploy loro skye ))<br>	(if (cdict X) ((p X yes)) ((p X no)) )<br>	(p '; ') (fail))<br>fuey no; ploy no; loro no; skye yes;<br>no</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipdict">dict</a>, <a href="frilmanual.html#bipdempdict">dempdict</a>, <a href="frilmanual.html#biprdict">rdict</a>, <a href="frilmanual.html#bipsys">sys</a>, <a href="frilmanual.html#bipidict">idict</a>, <a href="frilmanual.html#bipunivdict">univdict</a>, <a href="frilmanual.html#bipddict">ddict</a>, <a href="frilmanual.html#bipedict">edict</a>, menudict, dlogdict<h3>Notes</h3> <p> "cdict" is resatisfiable. </p><hr> <a name = "bipcharof"> </a><h2>charof  </h2><h3>Usage</h3><p> (charof <a href="glossary.html#char" target="gloss">&lt;char&gt;</a> <a href="glossary.html#int" target="gloss">&lt;int&gt;</a>) <br>(charof <a href="glossary.html#char" target="gloss">&lt;char&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>)<br>(charof <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> <a href="glossary.html#asc_int" target="gloss">&lt;asc_int&gt;</a>)</p><h3>Description</h3><p> "charof" converts ASCII values to characters and vice-versa. The first form checks that <a href="glossary.html#char" target="gloss">&lt;char&gt;</a> has the ASCII code <a href="glossary.html#int" target="gloss">&lt;int&gt;</a>. The second form binds <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> to the ASCII code of the character <a href="glossary.html#char" target="gloss">&lt;char&gt;</a>, and the third form binds <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> to the constant whose print-name is the single character with ASCII code <a href="glossary.html#asc_int" target="gloss">&lt;asc_int&gt;</a>.</p><h3> Behaviour </h3><p>Succeeds when the first argument is the ASCII code of the second argument, or when one argument can be instantiated to make this true. The ASCII code must be in the range 0 to 252.</p><h3>Example </h3><pre>?((charof a X) (sum X 1 Y) (charof Z Y) (pp X Y Z))<br>97<br>98<br>b<br></pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipname">name</a>, <a href="frilmanual.html#bipstringof">stringof</a>, <a href="frilmanual.html#bipstr_to_list">str_to_list</a>, <a href="frilmanual.html#bipgensym">gensym</a>, <a href="frilmanual.html#bipconvert">convert</a><h3>Cross-platform compatibility</h3> <p> Characters with ASCII codes in the range 128-252 may vary according to the font and operating system used.</p><hr> <a name = "bipcl"> </a><h2>cl  </h2><h3>Usage</h3><p> (cl <a href="glossary.html#clause" target="gloss">&lt;clause&gt;</a>) <br>(cl <a href="glossary.html#clause" target="gloss">&lt;clause&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>)<br>(cl <a href="glossary.html#clause" target="gloss">&lt;clause&gt;</a> <a href="glossary.html#int" target="gloss">&lt;int1&gt;</a> <int2>)<br>(cl <a href="glossary.html#clause" target="gloss">&lt;clause&gt;</a> <a href="glossary.html#int" target="gloss">&lt;int1&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>)<br>(cl <a href="glossary.html#clause" target="gloss">&lt;clause&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var1&gt;</a> <a href="glossary.html#int" target="gloss">&lt;int1&gt;</a> <int2>)<br>(cl <a href="glossary.html#clause" target="gloss">&lt;clause&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var1&gt;</a> <a href="glossary.html#int" target="gloss">&lt;int&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var2&gt;</a>)</p><h3>Description</h3><p> "cl" succeeds if the clause pattern <a href="glossary.html#clause" target="gloss">&lt;clause&gt;</a> matches a standard clause, a menu clause, a dialog clause, a dempster clause, or a tuple of a base relation in the knowledge base. The predicate of <a href="glossary.html#clause" target="gloss">&lt;clause&gt;</a> must be instantiated to a constant. If more than one match is found for <a href="glossary.html#clause" target="gloss">&lt;clause&gt;</a>, alternatives are given on backtracking. <br>The second form of "cl" also finds the support associated with the matching clause or tuple, and binds it to <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>. <br>The three argument form of "cl" starts the search for a match to <a href="glossary.html#clause" target="gloss">&lt;clause&gt;</a> at the <a href="glossary.html#int" target="gloss">&lt;int1&gt;</a>'th clause in the procedure. If <a href="glossary.html#clause" target="gloss">&lt;clause&gt;</a> matches the Nth clause, N is unified with the third argument. Thus a particular clause can be selected (third argument is an integer), or a clause numbering can be generated (third argument uninstantiated). <br>The four argument form is similar to three argument form, but the pair of support pairs associated with the clause is found and bound to <a href="glossary.html#var" target="gloss">&lt;var1&gt;</a>. <br>Tuples of relations are held in an internally determined order, and the three and four argument indexing forms of "cl" will generate an error message if used on relations.</p><h3> Behaviour </h3><p>Succeeds when <a href="glossary.html#clause" target="gloss">&lt;clause&gt;</a> matches a clause or tuple in the database. If more than one knowledge base item matches <a href="glossary.html#clause" target="gloss">&lt;clause&gt;</a>, cl is resatisfiable.</p><h3>Example </h3><pre>((numbered_list X)<br>	(cdict X)<br>	(pp)<br>	(cl ((X|ARGS)| BODY) SUPP 1 IND)<br>	(p IND)<br>	(p '.' ((X|ARGS)| BODY) : SUPP )<br>	(pp)<br>	(fail))<br>((numbered_list  _ ) (p end of definition) (pp))<br><br>((fred a)) : (0.9 1)<br>((fred b) (vacant c)) : ((0.7 0.8) (0 0.2)) <br><br>numbered_list fred<br></pre><br><pre>1. ((fred a)) : ((0.9 1) (0 1))<br>2. ((fred b) (vacant c)) : ((0.7 0.8) (0 0.2))<br>end of definition</pre><h3>See also</h3><p> <a href="frilmanual.html#bipaddcl">addcl</a>, <a href="frilmanual.html#bipdelcl">delcl</a>, <a href="frilmanual.html#bipdict">dict</a>, <a href="frilmanual.html#bipsys">sys</a>, <a href="frilmanual.html#bipdef">def</a>, <a href="frilmanual.html#biplist">list</a><h3>Notes</h3> <p> If the clause is a fact, or if the rule clause had only a single support pair attributed to it at the time of definition, then the second support pair in the pair of support pairs is always (0 1).</p><hr> <a name = "bipclose"> </a><h2>close  </h2><h3>Usage</h3><p> (close <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a>) <br></p><h3>Description</h3><p> "close" closes the input or output stream associated with the file <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a>. This stream must have been opened using "open", "create", or a related predicate. If the stream is open for output, then it is flushed before being closed.</p><h3> Behaviour </h3><p>Succeeds when <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a> refers to a currently open stream which is not pre-defined, otherwise fails.</p><h3>Example </h3><pre>?((open file1) (read file1 X) (pp X) (close file1))</pre><br><pre>reads the first term in file1, prints it on the screen, and then closes the file.</pre><h3>See also</h3><p> <a href="frilmanual.html#bipflush">flush</a>, <a href="frilmanual.html#bipopen">open</a>, <a href="frilmanual.html#bipcreate">create</a>, <a href="frilmanual.html#bipfilepos">filepos</a>, file<h3>Notes</h3> <p> It is an error to attempt to close any of the predefined streams, stdin, stdout, stderr. Files are automatically closed on a system reset to Fril top level. "close" cannot be used to close an edit window - use the goal (file close <a href="glossary.html#filename">&lt;filename&gt;</a>) instead.</p><hr> <a name = "bipcomplement"> </a><h2>complement  </h2><h3>Usage</h3><p> (complement <a href="glossary.html#named_fset" target="gloss">&lt;named_fset&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>) <br>(complement <a href="glossary.html#named_fset" target="gloss">&lt;named_fset&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>)</p><h3>Description</h3><p> Finds the complement of a fuzzy set, with respect to its universe. The two argument form returns an unnamed fuzzy set with no associated universe. The three argument form creates a new named fuzzy set with name <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> as a subset of the same universe as <a href="glossary.html#named_fset" target="gloss">&lt;named_fset&gt;</a>.</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#named_fset" target="gloss">&lt;named_fset&gt;</a> has an associated universe, and (in the three argument case) a new named fuzzy set can be created with name <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>. Fails otherwise.</p><h3>Example </h3><pre>set (r100 0 100)	% universe = interval 0-100<br>set (positive 0 pos_inf)	% universe = positive nos.<br><br>(i1 [0:0 10:1 20:0] r100)	% subset of interval 0-100<br>(i2 [0:0 10:1 20:0] positive)	% subset of interval 0-infinity<br>(i3 [0:0 10:1 20:0])<br><br>?((complement i1 X) (pp X))<br>[-0.01:0 0:1 10:0 20:1 100:1 100.01:0]<br>yes<br>?((complement i1 X noti1) (pp X))<br>[0:1 10:0 20:1 ]<br>yes<br><br>list noti1<br>(noti1 [0:1 10:0 20:1 ] r100)<br>yes<br>?((complement i3 X) (pp X))<br>no		% no universe defined</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipset_difference">set_difference</a>, <a href="frilmanual.html#bipunion">union</a>, <a href="frilmanual.html#bipintersection">intersection</a>, <a href="frilmanual.html#bipitype">itype</a>, <a href="frilmanual.html#bipdtype">dtype</a>, <a href="frilmanual.html#bipset">set</a>, <a href="frilmanual.html#bipget_univ">get_univ</a><h3>Notes</h3> <p> All occurrences of <a href="glossary.html#const">&lt;const&gt;</a> after a three-argument call to complement are replaced by the new fuzzy set definition. Any occurrences read by the system prior to the execution of this goal remain as the constant symbol <a href="glossary.html#const">&lt;const&gt;</a>.<br>The built-in predicate "set_difference" should be used to find complements when no universe is associated with a fuzzy set.</p><hr> <a name = "bipcon"> </a><h2>con  </h2><h3>Usage</h3><p> (con <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>) <br></p><h3>Description</h3><p> "con" tests whether its argument is a constant.</p><h3> Behaviour </h3><p>Succeeds when its argument is a constant, fails otherwise.</p><h3>Example </h3><pre>((test X) (con X) (pq X is a constant))<br>test abc<br>abc is a constant<br>yes<br>test 12<br>no<br>test ‘12’<br>‘12’ is a constant<br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipnum">num</a>,<a href="frilmanual.html#bipint"> int, </a>, <a href="frilmanual.html#bipvar">var</a>, <a href="frilmanual.html#bipatomic">atomic</a>, <a href="frilmanual.html#bipitype">itype</a>, <a href="frilmanual.html#bipdtype">dtype</a>, <a href="frilmanual.html#bipuniv">univ</a>, <a href="frilmanual.html#bipfset">fset</a>, <a href="frilmanual.html#bipconvert">convert</a><h3>Notes</h3> <p> If <a href="glossary.html#const">&lt;const&gt;</a> is the name of a fuzzy set definition, the goal (con <a href="glossary.html#const">&lt;const&gt;</a>) will fail. Any quoted string (other than a fuzzy set name) is a constant.</p><hr> <a name = "bipconj"> </a><h2>conj  </h2><h3>Usage</h3><p> (conj <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> ... <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a>) <br></p><h3>Description</h3><p> "conj" implements the limiting case of the theoretical support logic programming calculus for conjunction, which is appropriate when the dependencies of associated propositions are unknown. It accumulates the support for successive pairs of the support logic goals <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> to <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a> combining them using the limiting case calculus for conjunction described in Section >>6.19. If the support pair for <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> is (n1 p1) and the support pair for <a href="glossary.html#goal" target="gloss">&lt;goal2&gt;</a> is (n2 p2), then the support pair for the goal (conj <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> <a href="glossary.html#goal" target="gloss">&lt;goal2&gt;</a>) is given by the following:<br> (MAX{0, n1+n2-1}, MIN{p1, p2} )<br>This is in contrast to the default calculus which computes<br>(n1*n2, p1*p2).</p><h3> Behaviour </h3><p>"conj" always succeeds when given the correct argument types, since it is only used within queries evaluating supports. The support for the goal <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> is combined with the support for <a href="glossary.html#goal" target="gloss">&lt;goal2&gt;</a> using the limiting case calculus for conjunction described above. The combined support is then further combined with the support for <a href="glossary.html#goal" target="gloss">&lt;goal3&gt;</a> and so on in recursive fashion. If queried as a Fril Prolog goal, then it generates an error message and continues. </p><h3>Example </h3><pre>?((supp_query ((econ X)(safe X)(rel X)) S) (p X S) (pp))<br>and<br>?((supp_query ((conj (econ X)(safe X)(rel X))) S)<br>	(p X S) (pp))<br>are queries which contrast the default calculus for conjunction with "conj" in support logic programming theory. Assuming that the following support logic query,<br>?((supp_query ((design X Y)) S) (p X Y S) (pp) (fail))<br>returns:<br>	des_1 ok (0.7 0.9)<br>	des_2 ok (0.6 0.95)<br><br>the following support logic inferences are derived:<br><br>?((supp_query ((conj (design X Y) (design W Z))) S)<br>	(p X Y W Z S) (pp) (fail))<br><br>	des_1 ok des_1 ok (0.4 0.9)<br>	des_1 ok des_2 ok (0.3 0.9)<br>	des_2 ok des_1 ok (0.3 0.9)<br>	des_2 ok des_2 ok (0.2 0.95)<br>	no</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipand">and</a>, <a href="frilmanual.html#bipor">or</a>, <a href="frilmanual.html#bipdisj">disj</a>, <a href="frilmanual.html#bipnot">not</a>, <a href="frilmanual.html#bipsupp_query">supp_query</a><h3>Notes</h3> <p> This conjunction operator is of considerable theoretical interest, but it should be used with caution in Fril programs as its underlying assumption of unknown dependencies of propositions is usually too pessimistic and may result in a very rapid propagation of uncertainty in support inferences.</p><hr> <a name = "bipconvert"> </a><h2>convert  </h2><h3>Usage</h3><p> (convert <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a>) <br></p><h3>Description</h3><p> "convert" checks that <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> is the constant corresponding to the number <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a>, or performs the conversion between them.</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> is a constant and <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> is a number such that the constant is a string representation of the number. Alternatively, "convert" succeeds if one argument is a variable and can be bound so that <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> is a constant and <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> is a number as above. Otherwise "convert" fails.</p><h3>Example </h3><pre> ?((eq 123 N) (convert C N) (pq C N) (negg num C))<br>'123' 123 	% succeeds<br>?((eq '456.3' C) (convert C N) (pq C N) (num N))<br>'456.3' 456.3 	% succeeds<br></pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipname">name</a>, <a href="frilmanual.html#bipstringof">stringof</a>, <a href="frilmanual.html#bipcharof">charof</a>, <a href="frilmanual.html#bipnum">num</a>, <a href="frilmanual.html#bipcon">con</a><h3>Notes</h3> <p> This predicate is usually used in conjunction with input and output operations in which the user is considering terms character by character. The predicate "name" converts between constants and a list of ASCII codes. "convert" provides the necessary additional capability to convert between numbers and constants.</p><hr> <a name = "bipcos"> </a><h2>cos  </h2><h3>Usage</h3><p> (cos <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a>) <br></p><h3>Description</h3><p> "cos" checks that <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> is the cosine of <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a>, which is assumed to be an angle in radians, or performs the cosine or arccosine functional conversion between them.</p><h3> Behaviour </h3><p>Succeeds if both <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> and <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> are numbers and <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> is equal to the cosine of <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a>. Alternatively, if either argument is a variable while the other is a number, then the goal is satisfied by performing the appropriate evaluation as follows: <br>If <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> is a variable it is bound to the cosine of <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a>; and if <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> is a variable it is bound to the arccosine of <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a>, provided <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> lies in the interval -1 to 1. Any other values for the arguments cause an error message and the goal fails. </p><h3>Example </h3><pre>?((cos 3.145 C) (p C))<br>-1.0<br>yes<br>?((cos A 0.5)<br>	(times N 3.141592 A)<br>	(p Angle is N * Pi))<br>Angle is 0.33333 * Pi<br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsin">sin</a>, <a href="frilmanual.html#biptan">tan</a><hr> <a name = "bipcprintf"> </a><h2>cprintf  </h2><h3>Usage</h3><p> (cprintf <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> ... <a href="glossary.html#term" target="gloss">&lt;termn&gt;</a>) <br></p><h3>Description</h3><p> "cprintf" performs formatted printing of terms <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> to <a href="glossary.html#term" target="gloss">&lt;termn&gt;</a> on stream <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a> in a format specified by <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>. This predicate corresponds very closely to the 'C' programming language print function 'fprintf', thus: <br><a href="glossary.html#const" target="gloss">&lt;const&gt;</a> is a control string which can contain ordinary characters and conversion specifications. Ordinary characters are simply written to <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a>. The conversion specifications refer to the successive arguments <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> to <a href="glossary.html#term" target="gloss">&lt;termn&gt;</a>, in order, and begin with the character "%". The "%" is followed by field data and ends with a conversion character as defined below. The field data may be <br>(i) A minus sign indicating that the converted argument should be left adjusted within the field. The default is right adjustment. <br>(ii) A non-negative integer specifying a minimum field width. The converted number will be written in a field at least this wide. If the converted argument has fewer characters than the field width it will be appropriately padded on left or right, depending on whether the left adjustment indicator has been given. The padding character is a space, or zero if the field width was specified with a leading zero. <br>(iii) A full stop, which precedes the field width indicator. <br>(iv) A non-negative integer specifying the maximum number of characters to be written from a string, or the number of digits to be written to the right of the decimal point of a number. This is the precision. The conversion characters, which terminate the conversion specifications, characterise their arguments as follows: <br>c 	Argument is an ASCII code, and the corresponding character is written.<br>d	Argument is an integer and is converted to fall in the range -32768 to +32767. Preceding the d by an "l", extends to "long" integer range -2147483648 to +2147483647.<br>e	Argument is a floating point number and is converted to the following notation: (-)m.nnnnnnE(+ or -)xx where the length of the string of n's is specified by the precision. The default precision is 6.<br>f	Argument is a floating point number and is converted to the following decimal notation: (-)mmm.nnnn where the length of string of n's is specified by the precision. The default is 6.<br>g	Argument is a real number and is written using conversions "e" or "f", whichever is the shorter.<br>s	Argument is a constant and is either written whole, or until the field width characters are exhausted.</p><h3> Behaviour </h3><p>Always succeeds (assuming the arguments are of the correct form).</p><h3>Example </h3><pre>?((cprintf stdout "%s, %s %d, %02d:%02d" Saturday July 2 7 5))<br>Saturday, July 2, 07:05<br>yes<br>The following query prints "pi" to 5 decimal places:<br>?((tan X 1.0) (times X 4.0 Y)<br>	(cprintf stdout "pi = %.5f" Y) )<br>pi = 3.14159<br>yes<br>((print_supports F (L U))<br>	(cprintf F "(%4.2f %4.2f)" L U))<br>This procedure will write a support pair to the output<br>stream F, with each support rounded to 2 decimal places.<br>?((print_supports F (0.12638 0.87259) ))<br>(0.13 0.87)<br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipwrite">write</a>, <a href="frilmanual.html#bipwriteq">writeq</a>, <a href="frilmanual.html#bipw">w</a>, <a href="frilmanual.html#bipwq">wq</a>, <a href="frilmanual.html#bipp">p</a>, <a href="frilmanual.html#bippp">pp</a>, <a href="frilmanual.html#bippq">pq</a>, <a href="frilmanual.html#bipppq">ppq</a>, <a href="frilmanual.html#bipcreate">create</a>, <a href="frilmanual.html#bipcscanf">cscanf</a>, <a href="frilmanual.html#bipprlen">prlen</a>, <a href="frilmanual.html#bipwspaces">wspaces</a>, <a href="frilmanual.html#biptruncate">truncate</a><h3>Notes</h3> <p> If a character after the "%" is not a conversion character, then that character is written explicitly. If the wrong argument type is used for a particular conversion character, then spurious characters will be written. In particular, printing an integer using a float format may give unexpected results. If there are more arguments than conversion specification, then the arguments left over will not be written.</p><hr> <a name = "bipcputime"> </a><h2>cputime  </h2><h3>Usage</h3><p> (cputime <a href="glossary.html#var" target="gloss">&lt;var1&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var2&gt;</a>) <br></p><h3>Description</h3><p> "cputime" returns the current system time and the elapsed time since the last call to cputime. The time is, of course, only as accurate as the system clock.</p><h3> Behaviour </h3><p>Always succeeds. <a href="glossary.html#var" target="gloss">&lt;var1&gt;</a> is bound to the current system time in seconds, and <a href="glossary.html#var" target="gloss">&lt;var2&gt;</a> is bound to the number of seconds since the last call to cputime.</p><h3>Example </h3><pre>((run 0) (!))<br>((run X)(sum X -1 Y) (run Y))<br>?((cputime SYS1 START)<br>	(run 1000)<br>	(cputime SYS2 ELAPSED)<br>	(p program execution time: ELAPSED seconds))</pre><br><pre>program execution time : 0.086669 seconds<br>yes</pre><h3>See also</h3><p> <a href="frilmanual.html#bipstatistics">statistics</a>, <a href="frilmanual.html#bipkb_garbage">kb_garbage</a>, <a href="frilmanual.html#bipdate">date</a><h3>Cross-platform compatibility</h3> <p> The meaning of "current system time" in the above contexts is system dependent. On UNIX systems, this is the total CPU time since the current invocation of Fril. On Macintosh and Windows 3.1 systems it is the total actual time since Fril was invoked</p><hr> <a name = "bipcreate"> </a><h2>create  </h2><h3>Usage</h3><p> (create <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a>) <br></p><h3>Description</h3><p> "create" opens a file for output, and associates a stream with <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a>. If the file exists, it is overwritten.</p><h3> Behaviour </h3><p>Succeeds if the output stream is successfully opened.</p><h3>Example </h3><pre>?((create file1)<br>	(write file1 hello world)<br>	(close file1))</pre><br><pre>replaces the contents (if any) of file1 with:<br><br>hello<br>world</pre><h3>See also</h3><p> <a href="frilmanual.html#bipcreate_a">create_a</a>, <a href="frilmanual.html#bipcreate_r">create_r</a>, <a href="frilmanual.html#bipcreate_ra">create_ra</a>, <a href="frilmanual.html#bipopen">open</a>, <a href="frilmanual.html#bipclose">close</a>, <a href="frilmanual.html#bipflush">flush</a>, <a href="frilmanual.html#bipwrite">write</a>, file, <a href="frilmanual.html#bipexists">exists</a><hr> <a name = "bipcreate_a"> </a><h2>create_a  </h2><h3>Usage</h3><p> (create_a <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a>) <br></p><h3>Description</h3><p> "create_a" opens a file for output, and associates a stream with <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a>. If the file exists, further output is appended to the existing contents of the file. Either input or output operations may be used on the stream; however, sequences of input operations must be separated form sequences of output operations by a call to "flush" or "filepos".</p><h3> Behaviour </h3><p>Succeeds if the output stream is successfully opened.</p><h3>Example </h3><pre>?((create file1)<br>	(write file1 hello world)<br>	(close file1))<br>replaces the contents (if any) of file1 with:<br><br>hello<br>world<br><br>?((create_a file1)<br>	(write file1 hello again)<br>	(close file1))<br>updates the contents of file1 to:<br><br>hello<br>world<br>hello<br>again</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipcreate">create</a>, <a href="frilmanual.html#bipcreate_r">create_r</a>, <a href="frilmanual.html#bipcreate_ra">create_ra</a>, <a href="frilmanual.html#bipopen">open</a>, <a href="frilmanual.html#bipclose">close</a>, <a href="frilmanual.html#bipwrite">write</a>, file, <a href="frilmanual.html#bipexists">exists</a>, <a href="frilmanual.html#bipflush">flush</a>, <a href="frilmanual.html#bipfilepos">filepos</a><hr> <a name = "bipcreate_r"> </a><h2>create_r  </h2><h3>Usage</h3><p> (create_r <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a>) <br></p><h3>Description</h3><p> "create_r" opens a file for output and/or input, and associates a stream with <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a>. If the file exists it is overwritten. The file can be read from or written to using the Fril input/output built-in predicates; however, when switching between reading and writing there must be an intervening call to "flush" or "filepos".</p><h3> Behaviour </h3><p>Succeeds if the input/output stream is successfully opened.</p><h3>Example </h3><pre>?((create_r file1) (write file1 hello world)<br>	(filepos file1 0) (read file1 X) (pp X) (close file1) )</pre><br><pre>writes <br>hello<br>world<br>into file1, binds X to "hello", and prints<br>hello<br>on the screen.</pre><h3>See also</h3><p> <a href="frilmanual.html#bipcreate">create</a>, <a href="frilmanual.html#bipcreate_a">create_a</a>, <a href="frilmanual.html#bipcreate_ra">create_ra</a>, <a href="frilmanual.html#bipopen">open</a>, <a href="frilmanual.html#bipclose">close</a>, <a href="frilmanual.html#bipwrite">write</a>, file, <a href="frilmanual.html#bipexists">exists</a>, <a href="frilmanual.html#bipflush">flush</a>, <a href="frilmanual.html#bipfilepos">filepos</a><hr> <a name = "bipcreate_ra"> </a><h2>create_ra  </h2><h3>Usage</h3><p> (create_ra <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a>) <br></p><h3>Description</h3><p> "create_ra" opens a file for output or input, and associates a stream with <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a>. If the file exists, further output is appended to the existing contents of the file. Either input or output operations may be used on the stream; however, sequences of input operations must be separated from sequences of output operations by a call to "flush" or "filepos".</p><h3> Behaviour </h3><p>Succeeds if the input/output stream is successfully opened.</p><h3>Example </h3><pre>?((create file1) (write file1 hello world) (close file1))<br>replaces the contents (if any) of file1 with:<br>hello<br>world<br>?((create_ra file1) (write file1 goodbye)) <br>changes the contents of file1 to: <br>hello<br>world<br>goodbye<br>?((filepos file1 0) (read file1 X) (pp X) (close file1) )<br>binds X to hello, and prints<br>hello<br>on the screen.</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipcreate">create</a>, <a href="frilmanual.html#bipcreate_a">create_a</a>, <a href="frilmanual.html#bipcreate_r">create_r</a>, <a href="frilmanual.html#bipopen">open</a>, <a href="frilmanual.html#bipclose">close</a>, <a href="frilmanual.html#bipwrite">write</a>, file, <a href="frilmanual.html#bipexists">exists</a>, <a href="frilmanual.html#bipflush">flush</a>, <a href="frilmanual.html#bipfilepos">filepos</a><hr> <a name = "bipcscanf"> </a><h2>cscanf  </h2><h3>Usage</h3><p> (cscanf <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var1&gt;</a> ... <a href="glossary.html#var" target="gloss">&lt;varn&gt;</a>) <br></p><h3>Description</h3><p> "cscanf" performs formatted reading of terms from stream <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a> in a format specified by <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>. The terms are bound to variables <a href="glossary.html#var" target="gloss">&lt;var1&gt;</a> to <a href="glossary.html#var" target="gloss">&lt;varn&gt;</a>. This predicate corresponds very closely to the 'C' programming language input function 'fscanf', thus:<br><a href="glossary.html#const" target="gloss">&lt;const&gt;</a> is a control string which contains formats for the successive arguments <a href="glossary.html#var" target="gloss">&lt;var1&gt;</a> to <a href="glossary.html#var" target="gloss">&lt;varn&gt;</a> (except as detailed in (ii) below). Characters are read from the input stream up to a maximum format width (see (i) below), or until a character is found which does not conform to the format; this character will be read by the next read operation on the stream. The characters read in are converted into the appropriate type. Each format begins with the character "%", followed by optional field data and ends with a conversion character as defined below. The field data may be<br>(i) A non-negative integer specifying a maximum field width, i.e. the maximum number of characters that can be read. If the first character read does not conform to the format, the variable is left unbound; otherwise it is bound to the term read from the stream. Note that with %c and %s specifications, field width must be less than 127 characters because of Fril’s restriction on the length of constant names.<br>(ii) An asterisk, indicating that the converted argument should be ignored. Input takes place as in (i) above, but no variable binding is made.<br>The conversion characters, which terminate the format specifications, characterise their arguments as follows:<br>c 	Reads a single character (or sequence of characters if a field width is given). The corresponding Fril variable is bound to a constant. This is the only conversion specification which reads all characters specified by the field width (unless the input is terminated by end of file).<br>s	Reads a character string, terminated by a white space character or the field width. The corresponding Fril variable is bound to a constant. This specification differs from %c in that it can be used to read a variable length string, whereas %c reads the number of characters specified in its field width.<br>d	Reads a decimal integer, i.e. an optional sign and a sequence of digits terminated by field width or any character outside the range 0-9.<br>x	Reads a hex integer, i.e. an optional sign and a sequence of digits and upper/lower case a-f, terminated by field width or any character outside the ranges 0-9, a-f.<br>o	Reads an octal integer, i.e. an optional sign and a sequence of digits terminated by field width or any character outside the range 0-7.<br>e,f,g	Reads a floating point number i.e. an optionally signed string of digits, possibly containing a decimal point, optionally followed by an exponent field, containing the letter ‘e’ or ‘E’, an optional sign, and an integer.</p><h3> Behaviour </h3><p>Always succeeds, unless <end-of-file> is read. Variables are only bound if characters conforming to the format are read.</p><h3>Example </h3><pre>If the file f1 contains<br>abc def ghi 12 22.3<br>the query<br>?((open f1)(cscanf f1 ‘%s %7c %d %f’ A B C D) (pq A B C D))<br>prints<br>abc ‘def ghi’ 12 22.3</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipread">read</a>, <a href="frilmanual.html#bipread_suppterm">read_suppterm</a>, <a href="frilmanual.html#bipgetb">getb</a>, await_input, <a href="frilmanual.html#bipintok">intok</a>, <a href="frilmanual.html#bipcprintf">cprintf</a><h3>Notes</h3> <p> Mismatches between a format and the characters in the input stream can lead to unexpected problems - e.g. if the file f1 contains <br>23.2 3.7<br>the query ?((open f1)(cscanf f1 "%d %f" X Y)(p X Y)(close f1))<br>would print<br>23 0.2<br>whereas changing the %d in the format to %f, i.e. <br>?((open f1)(cscanf f1 "%f %f" X Y)(p X Y)(close f1))<br>would print<br>23.2 3.7<br>A warning message is printed if not all variables are bound by the call to cscanf, or if there are too few arguments for the specified format.</p><hr> <a name = "bipdate"> </a><h2>date  </h2><h3>Usage</h3><p> (date <a href="glossary.html#var" target="gloss">&lt;var1&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var2&gt;</a>) <br></p><h3>Description</h3><p> "date" binds variables <a href="glossary.html#var" target="gloss">&lt;var1&gt;</a> and <a href="glossary.html#var" target="gloss">&lt;var2&gt;</a> to strings representing the date and time respectively. These strings are of the following form:<br>	'Day Month Date Year'	/* the date */<br>and	'HH:MM:SS'	/* the time */</p><h3> Behaviour </h3><p>Succeeds if both of its arguments <a href="glossary.html#var" target="gloss">&lt;var1&gt;</a> and <a href="glossary.html#var" target="gloss">&lt;var2&gt;</a> are different uninstantiated variables, otherwise fails.</p><h3>Example </h3><pre>?((date X Y) (pp X Y))<br>Tue Jan 3 1995<br>15:24:15</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipcputime">cputime</a>, <a href="frilmanual.html#bipstatistics">statistics</a><hr> <a name = "bipddict"> </a><h2>ddict  </h2><h3>Usage</h3><p> (ddict <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>) <br></p><h3>Description</h3><p> "ddict" is used to check whether <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a named dtype fuzzy set, or to generate names of dtype fuzzy sets defined in the knowledge base.</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a named dtype fuzzy set defined in the knowledge base. If <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a variable, Fril will bind it to a named dtype fuzzy set (if any are defined), and will resatisfy the call if necessary.</p><h3>Example </h3><pre>set (days (Mon Tues Weds Thurs Fri Sat Sun))<br>(weekend {Fri:0.8 Sat:1.0 Sun:1.0 Mon:0.2} days)<br>(small_size [0:0 10:1 20:1 30:0] )<br>ddict days<br>no<br>ddict weekend<br>yes<br>ddict small_size<br>no</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipidict">idict</a>, <a href="frilmanual.html#bipunivdict">univdict</a>, <a href="frilmanual.html#bipfsetdict">fsetdict</a>, <a href="frilmanual.html#bipdict">dict</a>, <a href="frilmanual.html#bipdtype">dtype</a>, <a href="frilmanual.html#bipdtype_to_list">dtype_to_list</a>, <a href="frilmanual.html#bipdtype_name">dtype_name</a>, <a href="frilmanual.html#bipdempdict">dempdict</a><h3>Version 4 Compatibility</h3> <p> In Version 4.0, "ddict" referred to dempster predicates. This role is now fulfilled by the built-in predicate "dempdict"</p><hr> <a name = "bipdef"> </a><h2>def  </h2><h3>Usage</h3><p> (def <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>) <br>(def <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a>)</p><h3>Description</h3><p> If <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a variable or a constant, (def <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>) is equivalent to (dict <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>) and checks whether <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> names a procedure in the knowledge base. If the argument to def is a <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a> representing a possible goal, def succeeds only if <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a> can be unified with the head of some procedure in the knowledge base, otherwise def fails.</p><h3> Behaviour </h3><p>"def" succeeds when <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> names a procedure or is an uninstantiated variable, or <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a> is a goal which matches a clause head or tuple in the database. In the latter case, if <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a> contains variables, then these are not unified with any other terms when def succeeds, so that <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a> is effectively shielded against any spurious unifications which might have arisen in testing the goal pattern, by matching in the database.</p><h3>Example </h3><pre>((append () X X))<br>((append (H|T) L (H|S)) (append T L S))<br>% the following calls succeed:<br>def append<br>def (append X () Y)<br>def (append (a b c) (d e) (a 1 2 3 4))<br>% the following calls fail:<br>def (append X Y)<br>def (append (a b c) (d e) (1 2 3 4))</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipcl">cl</a>, <a href="frilmanual.html#bipdict">dict</a><h3>Notes</h3> <p> "def" (like dict) is resatisfiable.</p><hr> <a name = "bipdef_dtype"> </a><h2>def_dtype  </h2><h3>Usage</h3><p> (def_dtype <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#dtype" target="gloss">&lt;dtype&gt;</a>) <br>(def_dtype <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#dtype" target="gloss">&lt;dtype&gt;</a> <a href="glossary.html#univ" target="gloss">&lt;univ&gt;</a>)</p><h3>Description</h3><p> "def_dtype" defines <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> to be a named dtype with the associated fuzzy set <a href="glossary.html#dtype" target="gloss">&lt;dtype&gt;</a>. If the three argument form is used, the fuzzy set is defined to be a subset of the universe <a href="glossary.html#univ" target="gloss">&lt;univ&gt;</a>.</p><h3> Behaviour </h3><p>Succeeds when the named dtype can be added to the knowledge base. Fails if <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> already names an item in the knowledge base, or (in the three argument form) if <a href="glossary.html#dtype" target="gloss">&lt;dtype&gt;</a> is not a subset of <a href="glossary.html#univ" target="gloss">&lt;univ&gt;</a>.</p><h3>Example </h3><pre>?((def_dtype about4 {2:0.2 3:0.8 4:1 5:0.8 6:0.2}))<br>yes<br>p about4<br>{2:0.2 3:0.8 4:1 5:0.8 6:0.2}<br><br>qs((match about4  4))<br>((match {2:0.2 3:0.8 4:1 5:0.8 6:0.2} 4)) : (1 1)<br>no (more) solutions<br><br>qs((match about4 4.2))<br>((match {2:0.2 3:0.8 4:1 5:0.8 6:0.2} 4.2)) : (0 0)<br>no (more) solutions</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipdtype">dtype</a>, <a href="frilmanual.html#bipdtype_name">dtype_name</a>, <a href="frilmanual.html#bipdtype_to_list">dtype_to_list</a>, <a href="frilmanual.html#bipset">set</a>, <a href="frilmanual.html#bipload">load</a>, <a href="frilmanual.html#bipreload">reload</a>, <a href="frilmanual.html#bipdef_itype">def_itype</a>, <a href="frilmanual.html#bipkill">kill</a>, <a href="frilmanual.html#bipdtype_to_freq">dtype_to_freq</a><h3>Notes</h3> <p> All occurrences of <a href="glossary.html#const">&lt;const&gt;</a> after the call to def_dtype are replaced by the dtype definition.</p><hr> <a name = "bipdef_itype"> </a><h2>def_itype  </h2><h3>Usage</h3><p> (def_itype <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#itype" target="gloss">&lt;itype&gt;</a>) <br>(def_itype <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#itype" target="gloss">&lt;itype&gt;</a> <a href="glossary.html#univ" target="gloss">&lt;univ&gt;</a>)</p><h3>Description</h3><p> "def_itype" defines <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> to be a named itype with the associated fuzzy set <a href="glossary.html#itype" target="gloss">&lt;itype&gt;</a>. If the three argument form is used, the fuzzy set is defined to be a subset of the universe <a href="glossary.html#univ" target="gloss">&lt;univ&gt;</a>.</p><h3> Behaviour </h3><p>Succeeds when the named itype can be added to the knowledge base. Fails if <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> already names an item in the knowledge base, or (in the three argument form) if <a href="glossary.html#itype" target="gloss">&lt;itype&gt;</a> is not a subset of <a href="glossary.html#univ" target="gloss">&lt;univ&gt;</a>.</p><h3>Example </h3><pre>?((def_itype about4 [2:0 3:0.8 4:1 5:0.8 6:0]))<br>yes<br>p about4<br>[2:0 3:0.8 4:1 5:0.8 6:0]<br>qs((match about4  4))<br>((match [2:0 3:0.8 4:1 5:0.8 6:0] 4)) : (1 1)<br><br>no (more) solutions<br><br>qs((match about4 4.2))<br>((match [2:0 3:0.8 4:1 5:0.8 6:0] 4.2)) : (0.8  0.8)<br>no (more) solutions</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipitype">itype</a>, <a href="frilmanual.html#bipitype_name">itype_name</a>, <a href="frilmanual.html#bipitype_to_list">itype_to_list</a>, <a href="frilmanual.html#bipset">set</a>, <a href="frilmanual.html#bipload">load</a>, <a href="frilmanual.html#bipreload">reload</a>, <a href="frilmanual.html#bipdef_dtype">def_dtype</a>, <a href="frilmanual.html#bipkill">kill</a>, <a href="frilmanual.html#bipitype_to_freq">itype_to_freq</a><h3>Notes</h3> <p> All occurrences of <a href="glossary.html#const">&lt;const&gt;</a> after the call to def_itype are replaced by the itype definition.</p><hr> <a name = "bipdef_rel"> </a><h2>def_rel  </h2><h3>Usage</h3><p> (def_rel <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#nni" target="gloss">&lt;nni&gt;</a>) <br></p><h3>Description</h3><p> "def_rel" defines <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> to be a relation of arity <a href="glossary.html#nni" target="gloss">&lt;nni&gt;</a>. Subsequent calls to addcl will add tuples to the relation <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>.</p><h3> Behaviour </h3><p>Fails if <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> already names an item in the knowledge base, otherwise succeeds.</p><h3>Example </h3><pre>?((def_rel rel1 2)<br>	(addcl ((rel1 a b))) <br>	(list rel1))</pre><br><pre>(rel1<br>	(a b))</pre><h3>See also</h3><p> <a href="frilmanual.html#biprdict">rdict</a>, <a href="frilmanual.html#bipkill">kill</a>, <a href="frilmanual.html#bipaddcl">addcl</a><h3>Notes</h3> <p> It is not possible to add tuples of different arity to a relation.</p><hr> <a name = "bipdelcl"> </a><h2>delcl  </h2><h3>Usage</h3><p> (delcl <a href="glossary.html#clause" target="gloss">&lt;clause&gt;</a>) <br>(delcl <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#int" target="gloss">&lt;int&gt;</a>)</p><h3>Description</h3><p> "delcl" deletes clauses from the knowledge base. The first form deletes the first clause which matches <a href="glossary.html#clause" target="gloss">&lt;clause&gt;</a>. The second form deletes the <a href="glossary.html#int" target="gloss">&lt;int&gt;</a>th clause in the definition of the predicate named <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>.</p><h3> Behaviour </h3><p>Succeeds when it is able to delete the specified clause.</p><h3>Example </h3><pre>((pred a b))<br>((pred b c))<br>((pred a c))<br>any of the following queries would remove the second clause, i.e. ((pred b c))<br>delcl ((pred b c))<br>delcl ((pred b X))<br>delcl ((pred b | X))<br>?((delcl pred 2))<br><br>The following query shows the potential hazards of modifying code which is executable on backtracking:<br>?((pred X Y) (pp (X Y)) (delcl ((pred b c))) (fail))<br>(a b)<br>(b c)<br>The initial call to "pred" sets up a backtrack point to the code of the second clause. This code is executed on backtracking, but since this clause has been removed, no further solutions are found. In general, it can be difficult to predict behaviour in these circumstances and it is best to avoid programming in this style.</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipcl">cl</a>, <a href="frilmanual.html#bipkill">kill</a>, <a href="frilmanual.html#bipaddcl">addcl</a><h3>Notes</h3> <p> "delcl" is not resatisfiable. Only clauses may be deleted, and not tuples of a relation. Care is needed when deleting clauses from procedure definitions which are in use (or may be used on backtracking)</p><hr> <a name = "bipdempdict"> </a><h2>dempdict  </h2><h3>Usage</h3><p> (dempdict <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>) <br></p><h3>Description</h3><p> "dempdict" checks whether <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> names a dempster procedure in the knowledge base. If <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a variable, "dempdict" binds it to the name of a dempster procedure, assuming at least one dempster procedure has been defined. Different dempster procedure names can be generated by backtracking to "dempdict".</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> can be unified with the name of a dempster procedure in the knowledge base. If <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a variable, dempdict is resatisfiable.</p><h3>Example </h3><pre>(fuey [2:0, 5:0.7, 8:1])<br>dempster ploy<br>((ploy X) (skye X)) : (0.8 1)<br>((ploy X) (pedro X)) : (1 1)<br>(loro (span) (raul) ... )<br>((pedro X) ... )<br><br>?((member X (fuey ploy loro pedro))<br>	(if (dempdict X) ((p X yes)) ((p X no)) )<br>	(p '; ') (fail))<br>fuey no; ploy yes; loro no; pedro no;<br>no</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipdempster">dempster</a>, <a href="frilmanual.html#bipcl">cl</a>, <a href="frilmanual.html#bipdict">dict</a>, <a href="frilmanual.html#bipddict">ddict</a><h3>Version 4 Compatibility</h3> <p> This predicate was known as "ddict" in Version 4. The ddict predicate now refers to dtype fuzzy sets.</p><hr> <a name = "bipdempster"> </a><h2>dempster  </h2><h3>Usage</h3><p> (dempster <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>) <br></p><h3>Description</h3><p> "dempster" declares that support logic predicate name <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> is of type dempster, so that different clauses for the predicate correspond to independent viewpoints, and the supports are combined using the dempster combination rule.</p><h3> Behaviour </h3><p>Succeeds provided that <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> does not name an existing knowledge base item (i.e. procedure or fuzzy set definition). An error occurs if <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> has previously been defined.</p><h3>Example </h3><pre>dempster ploy<br>((ploy X) (skye X)) : (0.8 1)<br>((ploy X) (you  X)) : (1 1)<br>((skye a)) : (.7 .9)<br>((skye NoMore)) : (.8 .9)<br>((you a)) : (.4 .6)<br><br>qs((ploy X))<br><br>((ploy a)) : (0.736 1)<br>((ploy NoMore)) : (0.64 1)<br>no (more) solutions</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipcl">cl</a>, <a href="frilmanual.html#bipdempdict">dempdict</a>, <a href="frilmanual.html#bipaddcl">addcl</a>, <a href="frilmanual.html#bipkill">kill</a><h3>Notes</h3> <p> The dempster goal must be called before any clauses of the predicate <a href="glossary.html#const">&lt;const&gt;</a> are added to the knowledge base.</p><hr> <a name = "bipdict"> </a><h2>dict  </h2><h3>Usage</h3><p> (dict <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>) <br></p><h3>Description</h3><p> "dict" checks whether <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> names a procedure in the knowledge base. If <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a variable, dict binds it to the name of a procedure, and can be resatisfied by binding <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> to different procedure names.</p><h3> Behaviour </h3><p>Succeeds when <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> either names a procedure, or is a variable and there are procedures defined in the knowledge base.</p><h3>Example </h3><pre>?((dict X) (kill X) (fail))<br>will delete all procedures from the knowledge base (but not fuzzy sets).</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipdempdict">dempdict</a>, <a href="frilmanual.html#biprdict">rdict</a>, <a href="frilmanual.html#bipcdict">cdict</a>, <a href="frilmanual.html#bipunivdict">univdict</a>, <a href="frilmanual.html#bipidict">idict</a>, <a href="frilmanual.html#bipddict">ddict</a>, <a href="frilmanual.html#bipfsetdict">fsetdict</a>, <a href="frilmanual.html#bipsys">sys</a>, menudict, fdict, <a href="frilmanual.html#bipedict">edict</a>, dlogdict, editdict, <a href="frilmanual.html#bipwdict">wdict</a>, <a href="frilmanual.html#bipdef">def</a>, <a href="frilmanual.html#bipkill">kill</a>, <a href="frilmanual.html#bipcl">cl</a><h3>Notes</h3> <p> "dict" is resatisfiable.</p><hr> <a name = "bipdisj"> </a><h2>disj  </h2><h3>Usage</h3><p> (disj <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> ... <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a>) <br></p><h3>Description</h3><p> "disj" implements the limiting case of the theoretical support logic programming calculus for disjunction, which is appropriate when the dependencies of associated propositions are unknown. It accumulates the support for successive pairs of the support logic goals <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> to <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a> combining them using the limiting case calculus for disjunction described in Section >>6.19>>. If the support pair for <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> is (n1 p1) and the support pair for <a href="glossary.html#goal" target="gloss">&lt;goal2&gt;</a> is (n2 p2), then the support pair for the goal (disj <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> <a href="glossary.html#goal" target="gloss">&lt;goal2&gt;</a>) is given by the following:<br>( MAX{n1, n2}, MIN{1, p1+p2} )<br>This is in contrast to the default calculus which uses "or" instead of "disj" and computes the support pair (n1+n2-n1*n2, p1+p2-p1*p2)</p><h3> Behaviour </h3><p>"disj" always succeeds when given the correct argument types, since it is only used within queries evaluating supports. The support for the goal <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> is combined with the support for <a href="glossary.html#goal" target="gloss">&lt;goal2&gt;</a> using the formula above. The combined support is then further combined with the support for <a href="glossary.html#goal" target="gloss">&lt;goal3&gt;</a> and so on in recursive fashion. If queried as a Fril Prolog goal, "disj" generates an error message and continues.</p><h3>Example </h3><pre>Assuming that the following support logic query,<br>	?((supp_query ((design X Y)) S) (p X Y S) (pp) (fail))<br>returns:<br>	des_1 ok (0.7 0.9)<br>	des_2 ok (0.6 0.95)<br>the following support logic inferences are derived:<br>?((supp_query ((disj (design X Y) (design W Z))) S) (p X Y W Z S) (pp) (fail))<br><br>	des_1 ok des_1 ok (0.7 1)<br>	des_1 ok des_2 ok (0.7 1)<br>	des_2 ok des_1 ok (0.7 1)<br>	des_2 ok des_2 ok (0.6 1)<br><br>	no</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipand">and</a>, <a href="frilmanual.html#bipor">or</a>, <a href="frilmanual.html#bipconj">conj</a>, <a href="frilmanual.html#bipnot">not</a>, <a href="frilmanual.html#bipsupp_query">supp_query</a><h3>Notes</h3> <p> This disjunction operator is of theoretical interest, but should only be used with caution in programs as its underlying assumption of unknown dependencies is often too pessimistic and can result in a propagation of uncertainty in support pair inferences.</p><hr> <a name = "bipdivision"> </a><h2>division  </h2><h3>Usage</h3><p> (division <a href="glossary.html#num" target="gloss">&lt;num1&gt;</a> <a href="glossary.html#num" target="gloss">&lt;num2&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>) <br></p><h3>Description</h3><p> "division" is used to unify <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> with the integer value produced by dividing <a href="glossary.html#num" target="gloss">&lt;num1&gt;</a> by <a href="glossary.html#num" target="gloss">&lt;num2&gt;</a>. If <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a variable, then it will be bound to that value. This is equivalent to performing the real division and truncating the result. The goal is not resatisfiable.</p><h3> Behaviour </h3><p>"division" succeeds if <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> can be unified with the integer division of <a href="glossary.html#num" target="gloss">&lt;num1&gt;</a> by <a href="glossary.html#num" target="gloss">&lt;num2&gt;</a>, otherwise it fails.</p><h3>Example </h3><pre>?((division 19 5 X) (pp X) (division 19 5 X))<br>3<br>yes<br>?((times 5 X 19) (pp X) (times 5 X 19))<br>3.8<br>yes<br>?((division 19 5 X) (pp X) (times 5 X 19))<br>3<br>no</pre><br><h3>See also</h3><p> <a href="frilmanual.html#biptimes">times</a>, <a href="frilmanual.html#bipremainder">remainder</a>, <a href="frilmanual.html#biptruncate">truncate</a>, <a href="frilmanual.html#bipint">int</a><hr> <a name = "bipdtype"> </a><h2>dtype  </h2><h3>Usage</h3><p> (dtype <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>) <br></p><h3>Description</h3><p> "dtype" checks whether <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a discrete fuzzy set (named or otherwise)</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a discrete fuzzy set, fails otherwise.</p><h3>Example </h3><pre>(f1 {a:1 b:0.3 c:0.6})<br>dtype f1<br>yes<br>dtype {c:0.2 d:1 e:0.4}<br>yes<br>dtype a<br>no<br>dtype [0:0 1:1 2:0]<br>no</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipitype">itype</a>, <a href="frilmanual.html#bipfset">fset</a>, <a href="frilmanual.html#bipuniv">univ</a>, <a href="frilmanual.html#bipcon">con</a>, <a href="frilmanual.html#bipnum">num</a>, <a href="frilmanual.html#bipint">int</a>, <a href="frilmanual.html#bipatomic">atomic</a>, <a href="frilmanual.html#bipvar">var</a>, <a href="frilmanual.html#bipdtype_to_list">dtype_to_list</a>, <a href="frilmanual.html#bipddict">ddict</a>, <a href="frilmanual.html#bipdtype_name">dtype_name</a>, <a href="frilmanual.html#bipdef_dtype">def_dtype</a><hr> <a name = "bipdtype_name"> </a><h2>dtype_name  </h2><h3>Usage</h3><p> (dtype_name <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> <named_dtype>) <br>(dtype_name <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>)<br>(dtype_name <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <named_dtype>) </p><h3>Description</h3><p> "dtype_name" converts a constant into the dtype definition named by that constant, and vice-versa. It can also be used to check that a constant names a dtype. The first form binds <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> to the name of the dtype <named_dtype>. The second form binds <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> to the definition of the dtype named by <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>. The third form checks that <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> is the name of <named_dtype>.</p><h3> Behaviour </h3><p>Succeeds if the first argument names the dtype definition given by the second argument, or if one argument can be instantiated to make this so.</p><h3>Example </h3><pre>(dtp1 {a:0.2 b:1 c:0.7})<br>?((dtype_name X dtp1) (p X is defined as dtp1) (con X))</pre><br><pre>dtp1 is defined as {a:0.2 b:1 c:0.7}<br>yes</pre><h3>See also</h3><p> <a href="frilmanual.html#bipddict">ddict</a>, <a href="frilmanual.html#bipdtype">dtype</a>, <a href="frilmanual.html#bipitype_name">itype_name</a>, <a href="frilmanual.html#bipuniv_name">univ_name</a>, <a href="frilmanual.html#bipfset_name">fset_name</a>, <a href="frilmanual.html#bipdtype_to_list">dtype_to_list</a>, <a href="frilmanual.html#bipdef_dtype">def_dtype</a>, <a href="frilmanual.html#bipfset">fset</a>, <a href="frilmanual.html#bipitype">itype</a>, <a href="frilmanual.html#bipname">name</a>, <a href="frilmanual.html#bipstringof">stringof</a>, <a href="frilmanual.html#bipcon">con</a><h3>Notes</h3> <p> The second and third forms require the actual name of the dtype. Since Fril replaces all occurrences of a named dtype with the fuzzy set definition, the constant naming the dtype is only available from built-in predicates which create symbols (e.g. name, dtype_name), or from input which is processed before the definition of dtype <a href="glossary.html#const">&lt;const&gt;</a>.</p><hr> <a name = "bipdtype_to_freq"> </a><h2>dtype_to_freq  </h2><h3>Usage</h3><p> (dtype_to_freq <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> <a href="glossary.html#list" target="gloss">&lt;list&gt;</a> ) <br>(dtype_to_freq <dtype-fuzzy-set> <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>)</p><h3>Description</h3><p> dtype_to_freq converts between a dtype fuzzy set and a list of element-frequency pairs representing the least prejudiced distribution. In the first form of usage, if <a href="glossary.html#list" target="gloss">&lt;list&gt;</a> is bound to a list of k lists, each of the form (ni mi) where mi is in the range [0,1] for i=2,. . .,k, then <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> will be bound to a dtype fuzzy set containing the elements specified by ni with memberships given by mi . In the second form, a list of element/frequency pairs is created from the least prejudiced distribution corresponding to the dtype fuzzy set, and this list is unified with <a href="glossary.html#term" target="gloss">&lt;term&gt;</a></p><h3> Behaviour </h3><p>Succeeds if zero or one arguments can be instantiated to make the first argument a dtype fuzzy set, and the second argument a list of element-frequency pairs corresponding to the least prejudiced distribution of the fuzzy set.</p><h3>Example </h3><pre>?((dtype_to_freq {a:1 b:1 c:.4 d:0] L) (p L))<br>?((dtype_to_freq D ((a .6) (b .3) (c 0.1) )) (p D))</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipdtype_to_list">dtype_to_list</a>, <a href="frilmanual.html#bipexpected_value">expected_value</a>, <a href="frilmanual.html#bipitype_to_freq">itype_to_freq</a>, <a href="frilmanual.html#bipddict">ddict</a>, <a href="frilmanual.html#bipdtype">dtype</a>, <a href="frilmanual.html#bipdtype_name">dtype_name</a>, <a href="frilmanual.html#bipdef_dtype">def_dtype</a><hr> <a name = "bipdtype_to_list"> </a><h2>dtype_to_list  </h2><h3>Usage</h3><p> (dtype_to_list <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> <a href="glossary.html#list" target="gloss">&lt;list&gt;</a> ) <br>(dtype_to_list <a href="glossary.html#dtype" target="gloss">&lt;dtype&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>)</p><h3>Description</h3><p> "dtype_to_list" converts between a discrete fuzzy set and a list of element-membership pairs. In the first form of usage, if <a href="glossary.html#list" target="gloss">&lt;list&gt;</a> is bound to a list of lists, each containing a constant and a number in the interval [0,1] then <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> will be bound to a dtype fuzzy set containing the elements specified by the constants, with memberships given by the numbers. In the second form, a list of element/membership pairs is created from the discrete fuzzy set <a href="glossary.html#dtype" target="gloss">&lt;dtype&gt;</a>, and this list is unified with <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>.</p><h3> Behaviour </h3><p>Succeeds if zero or one arguments can be instantiated to make the first argument a dtype fuzzy set, and the second argument a list of element-membership pairs composing the dtype fuzzy set. </p><h3>Example </h3><pre>?((dtype_to_list {a:1 b:0.9 c:0.2} L) (p L))<br>((a 1) (b 0.9) (c 0.2))<br>yes<br>?((dtype_to_list F ((a 1) (b 0.9) (c 0.2))) (p F))<br>{a:1 b:0.9 c:0.2}<br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipddict">ddict</a>, <a href="frilmanual.html#bipdtype">dtype</a>, <a href="frilmanual.html#bipdtype_name">dtype_name</a>, <a href="frilmanual.html#bipdef_dtype">def_dtype</a>, <a href="frilmanual.html#bipdtype_to_freq">dtype_to_freq</a>, <a href="frilmanual.html#bipitype_to_list">itype_to_list</a><h3>Notes</h3> <p> Elements in a dtype are stored in a canonical order, which is internally determined. This may cause problems if <a href="glossary.html#term">&lt;term&gt;</a> is not a variable, e.g.<br>?((dtype_to_list F ((b 0.9)(a 1))) (pp F) (dtype_to_list F ((b 0.9) (a 1))))<br>prints <br>{a:1 b:0.9}<br>but fails in the third goal because ((b 0.9) (a 1)) and ((a 1) (b 0.9)) do not unify.</p><hr> <a name = "bipdynamic"> </a><h2>dynamic  </h2><h3>Usage</h3><p> (dynamic <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>) <br>(dynamic (<a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> ... <a href="glossary.html#const" target="gloss">&lt;constn&gt;</a>))</p><h3>Description</h3><p> This predicate is only relevant in the context of the construction of a module. "dynamic" is used to declare as dynamic, predicate name <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> in the first form, or each of the predicates <a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> to <a href="glossary.html#const" target="gloss">&lt;constn&gt;</a> in the second form. This is necessary when they (or it) are to be examined or altered at run time, by some other part of the same module.</p><h3> Behaviour </h3><p>Always succeeds (with no effect unless a module is being created)</p><h3>Example </h3><pre>(see module example)</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipmodule">module</a>, <a href="frilmanual.html#bipimport">import</a>, <a href="frilmanual.html#bipvisible">visible</a>, <a href="frilmanual.html#bipexport">export</a><h3>Notes</h3> <p> Fuzzy set definitions cannot be declared as dynamic. Dynamic predicates are stored in the knowledge base, and so are not hidden from the rest of the program. They must not be defined in the module itself and doing so will generate an error at compile time. The "dynamic" declaration has an effect similar to the import declaration in that it tells the module compiler that the definition for a particular predicate will be stored outside the module, in this case in the knowledge base. As a rough guide, any procedures which are manipulated by the built-in predicates for knowledge base access, such as dict, cl, kill, addcl etc., must be defined in the knowledge base and not in the module. If such a procedure is also called from the body of a rule in the module, then it must be declared as dynamic.</p><hr> <a name = "bipedict"> </a><h2>edict  </h2><h3>Usage</h3><p> (edict <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>) <br></p><h3>Description</h3><p> "edict" checks whether <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> names an export procedure. Thus, "edict" contains a dictionary of all the predicates exported by currently loaded modules, i.e. all module-defined user callable predicates.</p><h3> Behaviour </h3><p>Succeeds when <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> either names an export procedure, or is a variable and there are modules currently loaded which have export predicates.</p><h3>Example </h3><pre>?((edict X) (pp X) (fail))<br>displays the names of all the predicates which are exported by currently loaded modules.</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipmodule">module</a>, <a href="frilmanual.html#bipimport">import</a>, <a href="frilmanual.html#bipvisible">visible</a>, <a href="frilmanual.html#bipexport">export</a>, <a href="frilmanual.html#bipdict">dict</a>, <a href="frilmanual.html#bipmdict">mdict</a><h3>Notes</h3> <p> "edict" is resatisfiable.</p><hr> <a name = "bipeq"> </a><h2>eq  </h2><h3>Usage</h3><p> (eq <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a>) <br></p><h3>Description</h3><p> "eq" attempts to unify its two arguments. If it is embedded in a support query, the model of semantic unification specified by the supp_query goal is used.</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> and <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> unify, otherwise fails.</p><h3>Example </h3><pre>?((eq X (a b c)) (pp X))<br>(a b c)<br>?((eq (H|T) (a b c)) (p H T) (pp))<br>a (b c)<br>?((eq (a|T) (c d e)) (p T))<br>no<br>((test X Y) (eq X Y)) : ((1 1) (0 0))<br>(itp1 [0:0 1:1 2:0])<br>(itp2 [0:.5 1.5:1 2:0])<br>?((supp_query ((test itp1 itp2)) S)(pp S))<br>(0.175 0.958333)<br>?((supp_query ((test itp1 itp2)) S point_match)(pp S))<br>(0.574163 0.574163)<br>?((supp_query ((test itp1 itp2)) S poss_match)(pp S))<br>(0.333333 0.875)</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipstricteq">stricteq</a>, <a href="frilmanual.html#bipmatch">match</a>, <a href="frilmanual.html#bippoint_match">point_match</a>, <a href="frilmanual.html#bipposs_match">poss_match</a>, <a href="frilmanual.html#bipless_eq">less_eq</a>,  <a href="frilmanual.html#bipless">less</a><h3>Notes</h3> <p> "eq" incorporates semantic unification when embedded in a support query.</p><hr> <a name = "biperrm"> </a><h2>errm  </h2><h3>Usage</h3><p> (errm <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>) <br>(errm <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>)</p><h3>Description</h3><p> The first form of "errm" alters the error message status to <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>. When an error occurs, the current error message status, <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>, is passed to the error handler and can be used to control the action on the occurrence of errors. When the default error handler "error" is being used, the following options are expected:<br>"y"	This enables all error messages to be written to the stream "stderr". The appropriate error action is performed.<br>"n"	This turns off all control error messages that do not have the action "abort", and all interface error messages. The appropriate error action is still performed.<br>Input, support and module errors are always reported by the default error handler. When the second form of "errm" is used, the variable becomes bound to the current error message status. The default status is "y"</p><h3> Behaviour </h3><p>Always succeeds.</p><h3>Example </h3><pre>?((errm y) (read X) (pp X))<br>control error 131:<br>no definition for read with arity 1<br>(read _3)<br>(failing goal)<br>no<br>?((errm n) (read X) (pp X))<br>no</pre><br><h3>See also</h3><p> <a href="frilmanual.html#biperr_han">err_han</a>, <a href="frilmanual.html#biperror">error</a><hr> <a name = "biperror"> </a><h2>error  </h2><h3>Usage</h3><p> (error <a href="glossary.html#int" target="gloss">&lt;int1&gt;</a> control <a href="glossary.html#list" target="gloss">&lt;list&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const2&gt;</a>) <br>(error <a href="glossary.html#int" target="gloss">&lt;int1&gt;</a> input <a href="glossary.html#list" target="gloss">&lt;list&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const2&gt;</a> <int2>)<br>(error <a href="glossary.html#int" target="gloss">&lt;int1&gt;</a> support <a href="glossary.html#list" target="gloss">&lt;list&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>)<br>(error <a href="glossary.html#int" target="gloss">&lt;int1&gt;</a> module <a href="glossary.html#list" target="gloss">&lt;list&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const2&gt;</a> <const3>)<br>(error <a href="glossary.html#int" target="gloss">&lt;int1&gt;</a> interface <a href="glossary.html#list" target="gloss">&lt;list&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const2&gt;</a>)<br>(error <a href="glossary.html#int" target="gloss">&lt;int1&gt;</a> dialog <a href="glossary.html#list" target="gloss">&lt;list&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const2&gt;</a>)</p><h3>Description</h3><p> Prints error number <a href="glossary.html#int" target="gloss">&lt;int1&gt;</a> and error message contained in <a href="glossary.html#list" target="gloss">&lt;list&gt;</a>, according to the type of error and the current error message status, <a href="glossary.html#const" target="gloss">&lt;const1&gt;</a>. The remaining arguments are dependent on the type of error, and contain further information about the source of the error, and the appropriate action to take after the message is printed. See Section >>>16.25 for a complete description of these arguments.</p><h3> Behaviour </h3><p>Succeeds, fails or aborts according to the error type and number. Not resatisfiable.</p><h3>Example </h3><pre></pre><br><h3>See also</h3><p> <a href="frilmanual.html#biperr_han">err_han</a>, <a href="frilmanual.html#biperrm">errm</a>, <a href="frilmanual.html#bipabort">abort</a><h3>Notes</h3> <p> This predicate is used as the default error handler, and is not usually called from user programs. It is however commonly used in conjunction with the programmable error handler to report those errors which are not reprogrammed.</p><hr> <a name = "biperr_han"> </a><h2>err_han  </h2><h3>Usage</h3><p> (err_han <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>) <br>(err_han <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>)</p><h3>Description</h3><p> "err_han" reports or determines which error handler is to be used to handle errors reported by the system. At start-up this defaults to the system error handler "error". Error handling can be redirected to a user defined procedure named <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>. The procedure with this predicate name will then be used to define the consequent behaviour.</p><h3> Behaviour </h3><p>Always succeeds. Directs all error handling to the procedure named <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>, or reports the current error handler in <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>. The goal is not resatisfiable.</p><h3>Example </h3><pre>When writing a new error handler it is important to ensure that it will process all possible errors. The easiest way to achieve this is to use a "catch-all" rule that passes any unchanged errors to the default error handler. The following shows the recommended form: <br>err_han new_error 	% set up new error handler <br>((new_error &lt;number&gt; A B C D E) (!) <br>	% trap particular error<br>(.....))<br> ... <br>((new_error N A B C D E)<br>	(error N A B C D E))	% pass all other errors on</pre><br><h3>See also</h3><p> <a href="frilmanual.html#biperrm">errm</a>, <a href="frilmanual.html#biperror">error</a>, <a href="frilmanual.html#bipabort">abort</a>, <a href="frilmanual.html#bipfail">fail</a><hr> <a name = "bipevlog"> </a><h2>evlog  </h2><h3>Usage</h3><p> (evlog (<a href="glossary.html#itype" target="gloss">&lt;itype&gt;</a> <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> <a href="glossary.html#evwt" target="gloss">&lt;wt1&gt;</a> . . . <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a> <a href="glossary.html#evwt" target="gloss">&lt;wtn&gt;</a>)) <br>(evlog (<a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> <a href="glossary.html#evwt" target="gloss">&lt;wt1&gt;</a> . . . <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a> <a href="glossary.html#evwt" target="gloss">&lt;wtn&gt;</a>))</p><h3>Description</h3><p> "evlog" implements the Fril evidential support logic combination of goals in the body. It evaluates a weighted sum of necessary and possible supports, which are then scaled according to the fuzzy set <a href="glossary.html#itype" target="gloss">&lt;itype&gt;</a>. </p><h3> Behaviour </h3><p>"evlog" always succeeds when it is being used within queries evaluating supports. The sum of weighted supports for the goals <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> . . .<a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a> are combined using the fuzzy filter <a href="glossary.html#itype" target="gloss">&lt;itype&gt;</a> to give an overall support for the evidential rule body.</p><h3>Example </h3><pre>>>> EXAMPLE</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipgeneral">general</a><hr> <a name = "bipexists"> </a><h2>exists  </h2><h3>Usage</h3><p> (exists <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>) <br></p><h3>Description</h3><p> "exists" checks whether <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> is the name of an existing file. The ".frl" extension is not assumed and it must be explicitly in the string <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> where necessary. If no path is given, then "exists" looks in the current directory. If a path is given, "exists" searches the specified path for the file.</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> names an existing file, otherwise fails. The goal is not resatisfiable.</p><h3>Example </h3><pre>((create_new_file X) (exists X) (p 'ERROR:' file X exists) (!) (fail)) <br>((create_new_file X) (create X)) <br>?((create_new_file 'c:\fril\applics\output.frl')) <br>?((create_new_file 'frildir/applics/output.frl'))<br>?((create_new_file 'MacHD:Fril:Applics:output.frl'))<br>Each of these queries will check first and then create a new file called "output.frl" in the relevant directory. The first case uses MS-DOS path syntax, the second uses UNIX syntax, and the third uses Mac syntax.</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipfilename">filename</a>, find_file, <a href="frilmanual.html#bipopen">open</a>, <a href="frilmanual.html#bipcreate">create</a>, <a href="frilmanual.html#biptempfile">tempfile</a>, get_filename, <a href="frilmanual.html#bipcd">cd</a>, file<hr> <a name = "bipexit"> </a><h2>exit  </h2><h3>Usage</h3><p> (exit <a href="glossary.html#int" target="gloss">&lt;int&gt;</a>) <br></p><h3>Description</h3><p> "exit" terminates execution of Fril, and returns integer <a href="glossary.html#int" target="gloss">&lt;int&gt;</a> to the parent process (if appropriate to the operating system).</p><h3> Behaviour </h3><p>Terminates execution of Fril when its argument is an integer. Otherwise, prints an error message and fails.</p><h3>Example </h3><pre>((process update) ... )<br>((process run) ... )<br>((process quit)<br>	(p 'leaving Fril system - press <Enter> to continue:')<br>	(flush stdin)<br>	(getb stdin _)<br>	(exit 0)) </pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipabort">abort</a><hr> <a name = "bipexp"> </a><h2>exp  </h2><h3>Usage</h3><p> (exp <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a>) <br></p><h3>Description</h3><p> "exp" checks that <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> is the natural exponential of <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a>, i.e. <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> is "e" to the power of <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a>, or alternatively <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> is the natural logarithm of <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a>.</p><h3> Behaviour </h3><p>Succeeds if both <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> and <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> are numbers and <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> is equal to the exponential of <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a>. Alternatively, if either argument is a variable while the other is a number, then the goal is satisfied by performing the appropriate evaluation as follows: If <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> is a variable it is bound to the exponential of <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> and if <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> is a variable it is bound to the natural logarithm of <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a>. Any other values for the arguments causes the goal to fail.</p><h3>Example </h3><pre>((multiply A B C)<br>	(exp LA A) (exp LB B) (sum LA LB LC) (exp LC C))<br>performs multiplication of terms A and B to produce C, via logarithms.</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bippower">power</a>, <a href="frilmanual.html#bipsquare">square</a><hr> <a name = "bipexpected_value"> </a><h2>expected_value  </h2><h3>Usage</h3><p> (expected_value <a href="glossary.html#fset" target="gloss">&lt;fset&gt;</a><a href="glossary.html#var" target="gloss">&lt;var&gt;</a>) <br></p><h3>Description</h3><p> Calculates the expected value of a fuzzy set. ** to be continued **</p><h3> Behaviour </h3><p></p><h3>Example </h3><pre>>>> EXAMPLE</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsupp_expect">supp_expect</a>, <a href="frilmanual.html#bipqse">qse</a>, <a href="frilmanual.html#bipose">ose</a>, <a href="frilmanual.html#bipwse">wse</a>, <a href="frilmanual.html#bipse">se</a>, <a href="frilmanual.html#bipitype_to_freq">itype_to_freq</a>, <a href="frilmanual.html#bipdtype_to_freq">dtype_to_freq</a><hr> <a name = "bipexport"> </a><h2>export  </h2><h3>Usage</h3><p> (export <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>) <br>(export (<a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> ... <a href="glossary.html#const" target="gloss">&lt;constn&gt;</a>))</p><h3>Description</h3><p> This predicate is only relevant in the context of the construction of a module. In the first form, "export" is used to declare predicate name <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> as export. In the second form, each of the predicates <a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> to <a href="glossary.html#const" target="gloss">&lt;constn&gt;</a> is declared as export. Export declarations are necessary for all predicates defined in a module which are to be callable by the user. All predicates so declared can then be called from Fril top-level, or from other modules.</p><h3> Behaviour </h3><p>Always succeeds.</p><h3>Example </h3><pre></pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipmodule">module</a>, <a href="frilmanual.html#bipmodule_initialisation">module_initialisation</a>, <a href="frilmanual.html#bipimport">import</a>, <a href="frilmanual.html#bipvisible">visible</a>, <a href="frilmanual.html#bipedict">edict</a>, <a href="frilmanual.html#bipdynamic">dynamic</a>, <a href="frilmanual.html#bipdict">dict</a><h3>Notes</h3> <p> Fuzzy set definitions cannot be exported. Export declarations are exploited by the module compiler, and have no side effects outside the context of a module. This means that export declarations can be made in Fril source files prior to module compilation as a part of the program documentation.</p><hr> <a name = "bipfail"> </a><h2>fail  </h2><h3>Usage</h3><p> (fail)  <br></p><h3>Description</h3><p> "fail" is the Fril Prolog "negation as failure" primitive. In Fril prolog (depth search) execution mode, the goal (fail) can never be satisfied, and it causes Fril to backtrack. If fail is encountered when the system is evaluating supports, an error message occurs.</p><h3> Behaviour </h3><p>Always fails in depth search inference mode.</p><h3>Example </h3><pre>If append and reverse are the only predicates defined in the knowledge base, then <br>?((dict X) (pp X) (fail)) <br>produces<br>append<br>reverse<br>no </pre><br><h3>See also</h3><p> <a href="frilmanual.html#bip!"> ! </a>, <a href="frilmanual.html#bipneg">neg</a>, <a href="frilmanual.html#bipnegg">negg</a>, <a href="frilmanual.html#bipabort">abort</a>, <a href="frilmanual.html#biprepeat">repeat</a><hr> <a name = "bipfdict"> </a><h2>fdict  </h2><h3>Usage</h3><p> (fdict <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>) <br></p><h3>Description</h3><p> "fdict" checks whether <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> names a foreign language procedure. Thus, "fdict" contains a dictionary of all the predicates made accessible to Fril in the compilation of the foreign language interface routines using "xfril". </p><h3> Behaviour </h3><p>Succeeds when <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> either names a foreign language procedure, or is a variable and there exist foreign language interface predicates.</p><h3>Example </h3><pre>((extended_fril) <br>	(fdict _) (!) (p This is an extended version of Fril)) <br>"extended_fril" succeeds or fails according to whether or not there are foreign language procedures available.</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipdict">dict</a><h3>Notes</h3> <p> "fdict" is resatisfiable. The "xfril" package is available as a separate product.</p><hr> <a name = "bipfile"> </a><h2>file  </h2><h3>Usage</h3><p> Usage: (file <a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const2&gt;</a>) <br></p><h3>Description</h3><p> This built-in predicate enables the operations on the file menu to be performed under program control. <a href="glossary.html#const" target="gloss">&lt;const2&gt;</a> specifies a filename or the name of an edit window. <a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> specifies the operation to be performed, which should be one of<br>new	<a href="glossary.html#const" target="gloss">&lt;const2&gt;</a> is a filename. An edit window is created and the file <a href="glossary.html#const" target="gloss">&lt;const2&gt;</a> is overwritten or created. <br>open	<a href="glossary.html#const" target="gloss">&lt;const2&gt;</a> is the name of an existing file. An edit window is created for this file.<br>save	<a href="glossary.html#const" target="gloss">&lt;const2&gt;</a> is the name of an edit window whose contents are written to file.<br>close	<a href="glossary.html#const" target="gloss">&lt;const2&gt;</a> is the name of an edit window, which is closed after saving the contents.</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> is "new" or "open", and the file <a href="glossary.html#const" target="gloss">&lt;const2&gt;</a> can be opened for editing or can be created if <a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> is "new".<br>Succeeds if <a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> is "save" or "close" and <a href="glossary.html#const" target="gloss">&lt;const2&gt;</a> names an edit window<br>Fails in all other cases.</p><h3>Example </h3><pre>?((file new Fred))<br>creates an edit window "Fred"<br>?((editdict X)(file save X))<br>saves the contents of all open edit windows.</pre><br><h3>See also</h3><p> editdict, highlight, current_edit, <a href="frilmanual.html#bipcreate">create</a>, <a href="frilmanual.html#bipopen">open</a>, <a href="frilmanual.html#bipexists">exists</a>, <a href="frilmanual.html#bipfilename">filename</a>, edit, <a href="frilmanual.html#bipread">read</a>, <a href="frilmanual.html#bipwrite">write</a><h3>Notes</h3> <p> Errors from execution are handled using the failure-handling mechanism of the menu commands, i.e. a dialog box is displayed giving the reason for failure e.g. too many files open, file is already open, etc.<br>Closing an edit window under program control automatically saves the file first.</p><hr> <a name = "bipfilebcopy"> </a><h2>filebcopy  </h2><h3>Usage</h3><p> (filebcopy <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a> <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a> <a href="glossary.html#int" target="gloss">&lt;int&gt;</a>) <br>(filebcopy <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a> <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a> <a href="glossary.html#char" target="gloss">&lt;char&gt;</a>)</p><h3>Description</h3><p> "filebcopy" copies a block of bytes from <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a> to <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a>. The starting position of the block is the current position in <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a>, and the size of the block is defined by the last argument. The first form copies a block of size <a href="glossary.html#int" target="gloss">&lt;int&gt;</a> bytes, and the second form copies up to and including the first occurrence of the character <a href="glossary.html#char" target="gloss">&lt;char&gt;</a> in the <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a>. The resultant position in the <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a> will, in each case be the byte immediately following the last byte to be copied.</p><h3> Behaviour </h3><p>Succeeds if both <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a> and <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a> are currently open, and the block being copied does not include an end_of_file character. Fails otherwise.</p><h3>Example </h3><pre>?((create file1) (filebcopy stdin file1 '.') (close file1)) <br>will copy all input typed at the keyboard to the file "file1" until a full stop is encountered. <br>?((open file1) (create file2) (filebcopy file1 file2 10) (close file2)) <br>will copy the first ten bytes of file1 into file2.<br>If the file "fred" contains<br>	hello : (0.4 0.8)<br>	(list of terms) : 0.7<br>	unsupported allegation<br>then the query<br>?((file open fred)<br>	(filesearch fred ':') <br>	(filepos fred X)<br>	(filesearch fred ')')<br>	(filepos fred Y)<br>	(top_window fred)<br>	(highlight X Y))<br>will highlight the support pair on the first line.</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipfilepos">filepos</a>, <a href="frilmanual.html#bipfilesearch">filesearch</a>, file, edit<h3>Notes</h3> <p> Under some operating systems the end of the file is stored as directory information, and files do not always end with the end_of_file character. Under these circumstances "filebcopy" may read further than expected before failing on an end_of_file character. This may also leave the file position at a greater offset than the size of the file.</p><hr> <a name = "bipfilename"> </a><h2>filename  </h2><h3>Usage</h3><p> (filename <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> <term3>) <br>filename <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const2&gt;</a> <const3>) </p><h3>Description</h3><p> "filename" is used to convert between a fully specified file name and its associated path, root and extension. In the first form, <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> is a fully specified filename, and the goal will attempt to unify the path with <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a>, the root with <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> and the extension with <term3>. If any of <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a>, <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> and <term3> are variables, they are bound to the appropriate components of the complete filename <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>, if possible. In the second form, <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> is bound to the full filename constructed from the path <a href="glossary.html#const" target="gloss">&lt;const1&gt;</a>, the root <a href="glossary.html#const" target="gloss">&lt;const2&gt;</a> and the extension <const3>.</p><h3> Behaviour </h3><p>Succeeds if the first argument of the goal can be unified with a filename comprising a path, root and extension specified by arguments two, three and four, respectively. The goal is not resatisfiable.</p><h3>Example </h3><pre>An MS-DOS example: <br>?((filename F 'c:\fril\library' fs frl) (pq F)) 'c:\fril\library\fs.frl' <br>yes <br>A UNIX example: <br>?((filename '/mnt1/ren00p/prog.frm' P R E) (pq P R E)) <br>'/mnt1/ren00p' prog frm <br>yes<br>A Mac example: <br>?((cd X)(filename F X test frl)(ppq F))<br>'Mac HD:Fril Folder:test.frl'<br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bip name "> name </a>, <a href="frilmanual.html#bipexists">exists</a>, <a href="frilmanual.html#bipgetenv">getenv</a>, <a href="frilmanual.html#bipcd">cd</a>, get_filename<hr> <a name = "bipfilepos"> </a><h2>filepos  </h2><h3>Usage</h3><p> (filepos <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>) <br>(filepos <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a> <a href="glossary.html#nni" target="gloss">&lt;nni&gt;</a>)</p><h3>Description</h3><p> "filepos" binds <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> to the current offset in file <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a>, or changes the offset to <a href="glossary.html#nni" target="gloss">&lt;nni&gt;</a>.</p><h3> Behaviour </h3><p>In the first form, "filepos" always succeeds if <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a> names a currently open file, and binds <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> to the current offset. In the second form, the goal succeeds if <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a> is a currently open file and <a href="glossary.html#nni" target="gloss">&lt;nni&gt;</a> is a non- negative integer. The behaviour of "filepos" when the offset is greater than the size of the file will be dependent on the particular operating system under which Fril is running. The goal is not resatisfiable.</p><h3>Example </h3><pre>?((open file1) (filepos file1 X) (p X)) <br>0 <br>yes<br>the offset is zero on first opening the file.<br>?((filepos file1 20)) <br>will move the offset to 20.<br>If the file "fred" contains<br>	hello : (0.4 0.8)<br>	(list of terms) : 0.7<br>	unsupported allegation<br>then the query<br>?((file open fred)<br>	(filesearch fred ':') <br>	(filepos fred X)<br>	(filesearch fred ')')<br>	(filepos fred Y)<br>	(top_window fred)<br>	(highlight X Y))<br>will highlight the support pair on the first line.</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipfilebcopy">filebcopy</a>, <a href="frilmanual.html#bipfilesearch">filesearch</a>, file, edit, cursor_position, <a href="frilmanual.html#bipread">read</a>, <a href="frilmanual.html#bipwrite">write</a>, highlight, <a href="frilmanual.html#bipflush">flush</a><hr> <a name = "bipfilesearch"> </a><h2>filesearch  </h2><h3>Usage</h3><p> (filesearch <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>) <br></p><h3>Description</h3><p> "filesearch" searches forwards in the file <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a> from the current position until it finds <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>, which marks the new offset.</p><h3> Behaviour </h3><p>Succeeds if the <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a> is currently open for reading and the search string <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> can be found before an end_of_file character is encountered. The file position becomes the byte immediately following the last character in the search string <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>. The goal is not resatisfiable.</p><h3>Example </h3><pre>((search_file F C) (open F) (filesearch F C) (!) (p constant C found in file F) (pp) (close F)) ((search_file F C) (p constant C not found in file F) (close F)) </pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipfilepos">filepos</a>, <a href="frilmanual.html#bipfilebcopy">filebcopy</a>, <a href="frilmanual.html#bipopen">open</a>, <a href="frilmanual.html#bipclose">close</a>, file<h3>Notes</h3> <p> Under some operating systems the end of the file is stored as directory information, and files do not always end with the end_of_file character. Under these circumstances "filesearch" may search further than expected before failing on an end_of_file character. This may also leave the file position at a greater offset than the size of the file.</p><hr> <a name = "bipfindall"> </a><h2>findall  </h2><h3>Usage</h3><p> (findall <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> <a href="glossary.html#goal_list" target="gloss">goal_list</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>) <br></p><h3>Description</h3><p> "findall" finds all solutions to the list of goals <a href="glossary.html#goal_list" target="gloss">goal_list</a>, and for each solution collects <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> appropriately instantiated into a list which is unified with <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>.</p><h3> Behaviour </h3><p>"findall" succeeds if a solution to <a href="glossary.html#goal_list" target="gloss">goal_list</a> exists, otherwise it fails. The series of calls in <a href="glossary.html#goal_list" target="gloss">goal_list</a> are repeatedly executed and for each solution the corresponding instantiation of <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is collected into a list which is unified with <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>. The third argument <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> must be an uninstantiated variable which is bound to the appropriate list on completion of the findall goal.</p><h3>Example </h3><pre>((test a b a)) <br>((test d e f)) <br>((test g h g)) <br>?((findall (X Y) ((test X Y Z) (eq X Z)) L) (p L)) <br>((a b) (g h)) <br>yes </pre><br><h3>See also</h3><p> <a href="frilmanual.html#bip?"> ? </a>, <a href="frilmanual.html#bipforall">forall</a>, <a href="frilmanual.html#bipisall">isall</a><h3>Notes</h3> <p> The semantics of findall are almost identical to "isall". A slight difference is that, for "findall", the list of terms collected in <a href="glossary.html#var">&lt;var&gt;</a> appear in the same order that they are found. They appear in reverse order for "isall".</p><hr> <a name = "bipflush"> </a><h2>flush  </h2><h3>Usage</h3><p> (flush <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a>) <br>(flush <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a>)<br>(flush <io_stream>)</p><h3>Description</h3><p> "flush" clears the buffer associated with an input or output stream. If the stream is open for output, all buffered data is written to the associated file. Using flush on an input stream causes all immediately available input to be discarded.</p><h3> Behaviour </h3><p>Succeeds if the stream is open.</p><h3>Example </h3><pre>((get_char X)<br>	(p input?)<br>	(flush stdin) <br>	(get stdin X))<br>?((get_char X)(pp X))<br>Without the call to flush, it is possible that get_char will pick up spurious input.</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipgetb">getb</a>, getk, await_input, <a href="frilmanual.html#bippeekb">peekb</a>, peekk <a href="frilmanual.html#bipread">read</a>, <a href="frilmanual.html#bipopen">open</a>, <a href="frilmanual.html#bipcreate">create</a>, <a href="frilmanual.html#bipclose">close</a>, <a href="frilmanual.html#bipfilepos">filepos</a>, file<h3>Notes</h3> <p> An output stream is flushed automatically when it is closed. If <a href="glossary.html#in_stream">&lt;in_stream&gt;</a> is the standard input, all typed-ahead input is lost, and only input typed after the call to flush will be available to Fril. However, if <a href="glossary.html#in_stream">&lt;in_stream&gt;</a> is not stdin, all data from the file is discarded, leaving the file pointer at <end-of-file>. Thus the next read operation on the stream will fail because <end-of-file> has been reached. If the stream is open for input and output, a call to "flush" or "filepos" must appear between input and output operations on the stream.</p><hr> <a name = "bipfmem"> </a><h2>fmem  </h2><h3>Usage</h3><p> (fmem <a href="glossary.html#atom" target="gloss">&lt;atom&gt;</a> <a href="glossary.html#fset" target="gloss">&lt;fset&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>) <br></p><h3>Description</h3><p> fmem <a href="glossary.html#atom" target="gloss">&lt;atom&gt;</a> <a href="glossary.html#fset" target="gloss">&lt;fset&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a><br><br>finds membership of <a href="glossary.html#atom" target="gloss">&lt;atom&gt;</a> in <a href="glossary.html#fset" target="gloss">&lt;fset&gt;</a> and gives result in <a href="glossary.html#var" target="gloss">&lt;var&gt;</a><br><br>e.g.<br><br>?((fmem 1.2 [0:0 1:1 2:0] X)(pp X))<br><br>gives 0.8<br><br>?((fmem a {a:.4 b:1 c:.2} X)(pp X))<br>gives 0.4<br><br>Same as ?((supp_query ((match {a:.4 b:1 c:.2} a)) (X _)) (pp X))<br><br>but *much* less overhead!</p><h3> Behaviour </h3><p></p><h3>Example </h3><pre></pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipmatch"> match</a>, <a href="frilmanual.html#bippoint_match">point_match</a>, <a href="frilmanual.html#bipposs_match">poss_match</a>, <a href="frilmanual.html#bipeq">eq</a>, <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipdtype_to_list">dtype_to_list</a>, <a href="frilmanual.html#bipitype_to_list">itype_to_list</a><hr> <a name = "bipforall"> </a><h2>forall  </h2><h3>Usage</h3><p> (forall <a href="glossary.html#goal_list" target="gloss">&lt;goal_list1&gt;</a> <a href="glossary.html#goal_list" target="gloss">&lt;goal_list2&gt;</a>) <br></p><h3>Description</h3><p> "forall" repeatedly executes <a href="glossary.html#goal_list" target="gloss">&lt;goal_list1&gt;</a> and, for every solution and associated variable bindings, <a href="glossary.html#goal_list" target="gloss">&lt;goal_list2&gt;</a> is executed.</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#goal_list" target="gloss">&lt;goal_list2&gt;</a> is provable for all solutions to <a href="glossary.html#goal_list" target="gloss">&lt;goal_list1&gt;</a>. Any variable bindings made in proving <a href="glossary.html#goal_list" target="gloss">&lt;goal_list1&gt;</a> must also hold in proving <a href="glossary.html#goal_list" target="gloss">&lt;goal_list2&gt;</a>, but the "forall" call itself does not cause any variable bindings. Not resatisfiable.</p><h3>Example </h3><pre>((member X (X|_) )) <br>((member X (_|Y) ) (member X Y)) <br>?((forall ((member X (a b c) )) ((con X) (p con X) (pp)) )) con a <br>con b <br>con c <br>yes <br>?((forall ((member X (1 2 3) )) ((less Y 3)) )) <br>no</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bip?"> ? </a>, <a href="frilmanual.html#bipfindall">findall</a>, <a href="frilmanual.html#bipisall">isall</a><hr> <a name = "bipfset"> </a><h2>fset  </h2><h3>Usage</h3><p> (fset <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>) <br></p><h3>Description</h3><p> "fset " checks whether <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a universe, a continuous (itype) or a discrete (dtype) fuzzy set (named or otherwise)</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a fuzzy set, fails otherwise.</p><h3>Example </h3><pre>set (days (Mon Tues Weds Thurs Fri Sat Sun))<br>(weekend {Fri:0.8 Sat:1.0 Sun:1.0 Mon:0.2} days)<br>(small_size [0:0 10:1 20:1 30:0] )<br><br>fset days<br>fset weekend<br>fset small_size<br>fset [0:0 1:1 2:0]<br>all succeed.<br>fset hello<br>fails.</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipcon">con</a>, <a href="frilmanual.html#bipnum">num</a>, <a href="frilmanual.html#bipint">int</a>, <a href="frilmanual.html#bipitype">itype</a>, <a href="frilmanual.html#bipdtype">dtype</a>, <a href="frilmanual.html#bipuniv">univ</a>, <a href="frilmanual.html#bipatomic">atomic</a>, <a href="frilmanual.html#bipvar">var</a>, <a href="frilmanual.html#bipfsetdict">fsetdict</a>, <a href="frilmanual.html#bipfset_name">fset_name</a><hr> <a name = "bipfsetdict"> </a><h2>fsetdict  </h2><h3>Usage</h3><p> (fsetdict <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>) <br></p><h3>Description</h3><p> "fsetdict" is used to check whether <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a universe or named fuzzy set, or to generate names of universes or fuzzy sets defined in the knowledge base. Both itype (continuous) and dtype (discrete) fuzzy sets are included.</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a universe or named itype or dtype fuzzy set defined in the knowledge base. If <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a variable, Fril will bind it to a universe or named fuzzy set (if any are defined), and will resatisfy the call if necessary.</p><h3>Example </h3><pre>set (days (Mon Tues Weds Thurs Fri Sat Sun))<br>(weekend {Fri:0.8 Sat:1.0 Sun:1.0 Mon:0.2} days)<br>(small_size [0:0 10:1 20:1 30:0] )<br>ddict days<br>no<br>ddict weekend<br>yes<br>ddict small_size<br>no</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipidict">idict</a>, <a href="frilmanual.html#bipddict">ddict</a>, <a href="frilmanual.html#bipunivdict">univdict</a>, <a href="frilmanual.html#bipdict">dict</a>, <a href="frilmanual.html#bipfset">fset</a>, <a href="frilmanual.html#bipfset_name">fset_name</a><hr> <a name = "bipfset_name"> </a><h2>fset_name  </h2><h3>Usage</h3><p> (fset_name <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> <a href="glossary.html#named_fset" target="gloss">&lt;named_fset&gt;</a>) <br>(fset_name <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>)<br>(fset_name <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#named_fset" target="gloss">&lt;named_fset&gt;</a>) </p><h3>Description</h3><p> "fset_name" converts a constant into the fuzzy set or universe definition named by that constant, and vice-versa. It can also be used to check that a constant names a fuzzy set or universe. The first form binds <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> to the name of the fuzzy set <a href="glossary.html#named_fset" target="gloss">&lt;named_fset&gt;</a>. The second form binds <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> to the definition of the fuzzy set or universe named by <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>. The third form checks that <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> is the name of <a href="glossary.html#named_fset" target="gloss">&lt;named_fset&gt;</a>.</p><h3> Behaviour </h3><p>Succeeds if the first argument names the fuzzy set definition given by the second argument, or if one argument can be instantiated to make this so.</p><h3>Example </h3><pre>set (days (Mon Tues Weds Thurs Fri Sat Sun))<br>(weekend {Fri:0.8 Sat:1.0 Sun:1.0 Mon:0.2} days)<br>(small_size [0:0 10:1 20:1 30:0] )<br><br>qh((fset_name F small_size))<br>((fset_name small_size [0:0 10:1 20:1 30:0]))<br>no (more) solutions<br><br>qh((fset_name F days))<br><br>((fset_name days {Fri:1 Sat:1 Sun:1 Thurs:1 Weds:1 Tues:1 Mon:1}))</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipdtype_name">dtype_name</a>, <a href="frilmanual.html#bipitype_name">itype_name</a>, <a href="frilmanual.html#bipuniv_name">univ_name</a>, <a href="frilmanual.html#bipfsetdict">fsetdict</a>, <a href="frilmanual.html#bipfset">fset</a>, <a href="frilmanual.html#bipname">name</a>, <a href="frilmanual.html#bipstringof">stringof</a>, <a href="frilmanual.html#bipcon">con</a><h3>Notes</h3> <p> The second and third forms require the actual name of the fuzzy set. Since Fril replaces all occurrences of a named fuzzy set with the fuzzy set definition, the constant naming the fuzzy set is only available from built-in predicates which create symbols (e.g. name, dtype_name), or from input which is processed before the definition of fuzzy set <a href="glossary.html#named_fset">&lt;named_fset&gt;</a>.</p><hr> <a name = "bipgen"> </a><h2>gen  </h2><h3>Usage</h3><p>  (gen <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> (<a href="glossary.html#goal_list" target="gloss">&lt;goal_list1&gt;</a> . . . <a href="glossary.html#goal_list" target="gloss">&lt;goal_listn&gt;</a>) (<a href="glossary.html#support" target="gloss">&lt;support1&gt;</a>. . .<a href="glossary.html#support" target="gloss">&lt;supportn&gt;</a>)) <br></p><h3>Description</h3><p> "gen" implements a generalised version of the extended Fril rule, where <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> specifies the support logic operator to be used in combining the supports for goals in each <a href="glossary.html#goal_list" target="gloss">goal_list</a> (e.g. "conj" or "and"). Each <a href="glossary.html#goal_list" target="gloss">goal_list</a> is a conjunction of support logic goals, and the list <a href="glossary.html#goal_list" target="gloss">&lt;goal_list1&gt;</a> . . . <a href="glossary.html#goal_list" target="gloss">&lt;goal_listn&gt;</a> represents a mutually exclusive and exhaustive set of conditions. Each <a href="glossary.html#support" target="gloss">&lt;support&gt;</a> is a conditional support pair for the corresponding <a href="glossary.html#goal_list" target="gloss">goal_list</a>.</p><h3> Behaviour </h3><p>"gen" always succeeds when it is being used within queries evaluating supports. The overall support is calculated according to the algorithm given in Section 4.2 of  "Fril - Fuzzy and Evidential Reasoning in AI".</p><h3>Example </h3><pre>(<br>((h2) (gen conj<br>	( ((b1)) ((b2)) ((b3)) ((b4)) )<br>	( (0.5 0.7) (0.2 0.9) (0.3 0.5) (0.7 0.8) ) )) : ((1 1) (0 0))<br><br>((b1)) : (0.1 0.2)<br>((b2)) : (0.3 0.4)<br>((b3)) : (0 0.6)<br>((b4)) : (0 1)<br><br>qs((h2))<br>((h2)) : (0.28 0.83)<br>no (more) solutions</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipevlog">evlog</a>, <a href="frilmanual.html#bipgeneral">general</a><h3>Notes</h3> <p> The notation for writing extended Fril rules described in "Fril - Fuzzy and Evidential Reasoning in AI" is not implemented in Version 5.0, and the meta predicates "gen" or "general" should be used instead.</p><hr> <a name = "bipgeneral"> </a><h2>general  </h2><h3>Usage</h3><p>  (general (<a href="glossary.html#goal_list" target="gloss">&lt;goal_list1&gt;</a> . . . <a href="glossary.html#goal_list" target="gloss">&lt;goal_listn&gt;</a>) (<a href="glossary.html#support" target="gloss">&lt;support1&gt;</a>. . .<a href="glossary.html#support" target="gloss">&lt;supportn&gt;</a>)) <br></p><h3>Description</h3><p> "general" implements the extended Fril rule. Each <a href="glossary.html#goal_list" target="gloss">goal_list</a> is a conjunction of support logic goals, and the list <a href="glossary.html#goal_list" target="gloss">&lt;goal_list1&gt;</a> . . . <a href="glossary.html#goal_list" target="gloss">&lt;goal_listn&gt;</a> represents a mutually exclusive and exhaustive set of conditions. Each <a href="glossary.html#support" target="gloss">&lt;support&gt;</a> is a conditional support pair for the corresponding <a href="glossary.html#goal_list" target="gloss">goal_list</a>.</p><h3> Behaviour </h3><p>"general" always succeeds when it is being used within queries evaluating supports. The overall support is calculated according to the algorithm given in Section 4.2 of  "Fril - Fuzzy and Evidential Reasoning in AI".</p><h3>Example </h3><pre>((h) (general<br>	( ((b1)) ((b2)) ((b3)) ((b4)) )<br>	( (0.5 0.7) (0.2 0.9) (0.3 0.5) (0.7 0.8) ) )) : ((1 1) (0 0))<br><br>((b1)) : (0.1 0.2)<br>((b2)) : (0.3 0.4)<br>((b3)) : (0 0.6)<br>((b4)) : (0 1)<br>qs((h))<br>((h)) : (0.28 0.83)<br>no (more) solutions</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipevlog">evlog</a>, <a href="frilmanual.html#bipgen">gen</a><h3>Notes</h3> <p> The notation for writing extended Fril rules described in "Fril - Fuzzy and Evidential Reasoning in AI" is not implemented in Version 5.0, and the meta predicates "gen" or "general" should be used instead.</p><hr> <a name = "bipgensym"> </a><h2>gensym  </h2><h3>Usage</h3><p> (gensym <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>) <br></p><h3>Description</h3><p> "gensym" generates a new symbol or string from a root specified in <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>. <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> becomes instantiated to a string which comprises the characters of <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> followed by one or more digits. Each time Fril is started up, the first call to (gensym <root> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>) instantiates <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> to the string <root> followed by index 1. On each subsequent call of gensym, with the same <root>, the index is incremented by 1 for that <root> only.</p><h3> Behaviour </h3><p>"gensym" succeeds if its first argument is a string or constant and its second argument is a variable, or a string which matches the next symbol to be generated in the sequence. Otherwise gensym fails. gensym is not resatisfiable.</p><h3>Example </h3><pre>?((gensym help X) (pq X) (fail)) <br>help1<br>no<br>?((repeat) (gensym help X) (pq X) (p ' ') (fail)) <br>prints the following endless sequence, which can only be terminated by pressing the interrupt key. <br>help2 help3 help4 help5 help6 help7 help8 ... etc.<br>?((gensym newhelp X) (pq X) (fail)) <br>newhelp1<br>no </pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipname">name</a>, <a href="frilmanual.html#bipstringof">stringof</a>, <a href="frilmanual.html#bipcharof">charof</a>, <a href="frilmanual.html#biprandom">random </a>, <a href="frilmanual.html#biptempfile">tempfile</a><hr> <a name = "bipget"> </a><h2>get  </h2><h3>Usage</h3><p> (get <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>) <br></p><h3>Description</h3><p> "get" reads the next non-space character from the input stream <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a>, and binds its ASCII code to <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>. Space and control characters are ignored.</p><h3> Behaviour </h3><p>If <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a> is stdin, get waits until a valid character is passed to the standard input stream. Otherwise, the next character is available immediately.</p><h3>Example </h3><pre>?((get stdin X) (pp X))<br>will read the next non-space character typed at the terminal, and display its ASCII value.</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipgetb">getb</a>, getk, await_input, peek, <a href="frilmanual.html#bippeekb">peekb</a>, peekk, <a href="frilmanual.html#bipclose">close</a>, <a href="frilmanual.html#bipr">r</a>, <a href="frilmanual.html#bipread">read</a>, <a href="frilmanual.html#bipputb">putb</a>, <a href="frilmanual.html#bipintok">intok</a>, <a href="frilmanual.html#bipcscanf">cscanf</a><h3>Notes</h3> <p> "get" fails on end_of_file. Note that use of "get" can change the classification of the next token read. For example, consider the following query when file "file1" is open and contains the text "a_line" on a line, thus: a_line ?((get file1 X) (read file1 Y) (process Y)) This would pass the variable _line to process, whereas the same query without the "get" would read a constant, "a_line", and pass this to process.</p><hr> <a name = "bipgetb"> </a><h2>getb  </h2><h3>Usage</h3><p> (getb <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>) <br></p><h3>Description</h3><p> "getb" reads the next character from the input stream <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a>, and binds its ASCII code to <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>. All characters, including space and controls are returned.</p><h3> Behaviour </h3><p>If <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a> is stdin, getb waits until a valid character is passed to the standard input stream. Otherwise, the next character is available immediately.</p><h3>Example </h3><pre>?((getb stdin X) (pp X))<br>reads the next character typed at the terminal, and displays its ASCII value. If the query is typed from top level the next character will be the <CR> just typed.</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipget">get</a>, getk, await_input, <a href="frilmanual.html#bippeekb">peekb</a>, <a href="frilmanual.html#bipflush">flush</a>, <a href="frilmanual.html#bipr">r</a>, <a href="frilmanual.html#bipread">read</a>, <a href="frilmanual.html#bipputb">putb</a>, <a href="frilmanual.html#bipintok">intok</a>, <a href="frilmanual.html#bipcscanf">cscanf</a><h3>Notes</h3> <p> "getb" fails on end of file. Use of "getb" can change the classification of the next token read. For example, consider the following query when file "file1" is open and contains the text "a_line" on a line, thus: a_line ?((getb file1 X) (read file1 Y) (process Y)) This would pass the variable _line to process, whereas the same query without the "getb" would read a constant, "a_line", and pass this to process.</p><hr> <a name = "bipgetenv"> </a><h2>getenv  </h2><h3>Usage</h3><p> (getenv <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>) <br></p><h3>Description</h3><p> "getenv" checks that the environment variable (for example "frlib") given by <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> has the value given by <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>. The values of environment variables "frlib", "frpath" and "frhelp" are typically set to appropriate directory paths.</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a string representing the value of environment variable <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>. If <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a variable then it is bound to the appropriate value.</p><h3>Example </h3><pre>?((getenv frhelp X) (p X)) <br>c:\fril\help <br>yes <br>(this is an MS-DOS filename)</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsetenv">setenv</a>, <a href="frilmanual.html#bipcd">cd</a>, <a href="frilmanual.html#bipfilename">filename</a><h3>Notes</h3> <p> On MS-DOS based systems, where the operating system is case insensitive, "getenv" converts any uppercase characters in <a href="glossary.html#const">&lt;const&gt;</a> to lowercase before accessing DOS. This conversion is not performed on case sensitive operating systems such as UNIX.<br>On a Macintosh, there is no system facility for setting environment variables, and "setenv" is private to Fril. The best way to automatically set environment variables on a Mac is to place setenv commands in the file fril.boot. </p><hr> <a name = "bipget_prior"> </a><h2>get_prior  </h2><h3>Usage</h3><p> (get_prior <a href="glossary.html#univ" target="gloss">&lt;univ&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>) <br>(get_prior <a href="glossary.html#univ" target="gloss">&lt;univ&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>)</p><h3>Description</h3><p> "get_prior" extracts the prior probability distribution associated with the universe <a href="glossary.html#univ" target="gloss">&lt;univ&gt;</a>. </p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#univ" target="gloss">&lt;univ&gt;</a> is a universe with an associated prior which can be unified with the second term. Fails otherwise.</p><h3>Example </h3><pre>set (abcDomain (a b c) ((a 0.4) (b 0.2) (c 0.4)))<br>set (tenDomain 0 10)<br>?((fsetdict F)(pp)(pq F)(get_prior F X)(p)(p has prior X)(fail))<br></pre><br><pre>tenDomain<br>abcDomain has prior ((a 0.4) (b 0.2) (c 0.4))<br>no</pre><h3>See also</h3><p> set, <a href="frilmanual.html#bipget_univ">get_univ</a>, <a href="frilmanual.html#bipunivdict">univdict</a>, <a href="frilmanual.html#bippoint_match">point_match</a>, <a href="frilmanual.html#bipsupp_query">supp_query</a><h3>Notes</h3> <p> The prior is represented as a list of <a href="glossary.html#element">&lt;element</a>, <a href="glossary.html#probability">element&gt;</a> pairs. The order in which these pairs are held is determined internally, and may not match the order in which they were entered. The second form of usage may therefore fail unexpectedly due to ordering. For example<br>set (un (a b) ((b .6) (a .4)))<br>?((get_prior un ((b .6) (a .4)))<br>fails because the list of element/probability pairs is not in the internal order.<br>?((get_prior un X)(pp X))<br>succeeds and prints  ((a .4) (b .6))</p><hr> <a name = "bipget_univ"> </a><h2>get_univ  </h2><h3>Usage</h3><p> (get_univ <a href="glossary.html#named_fset" target="gloss">&lt;named_fset&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>) <br></p><h3>Description</h3><p> If a named fuzzy set is defined as a subset of a universe, get_univ gives access to the universe from the fuzzy set definition.</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#named_fset" target="gloss">&lt;named_fset&gt;</a> was defined as a subset of a universe, and binds <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> to the fuzzy set representation of the universe. Fails otherwise.</p><h3>Example </h3><pre>set (days (Mon Tues Weds Thurs Fri Sat Sun))<br>(weekend {Fri:0.8 Sat:1.0 Sun:1.0 Mon:0.2} days)<br>(small_size [0:0 10:1 20:1 30:0] )<br><br>((fuzz X) (ddict X))<br>((fuzz X) (idict X))<br>((report F) (get_univ F U) (!) (pq F has universe U))<br>((report F) (pq F has no universe))<br>?((fuzz F) (report F) (pp) (fail))<br>weekend has universe days<br>small_size has no universe<br>no</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipset">set</a>, <a href="frilmanual.html#bipuniv">univ</a>, <a href="frilmanual.html#bipcomplement">complement</a>, <a href="frilmanual.html#bipget_prior">get_prior</a>, <a href="frilmanual.html#bipuniv_name">univ_name</a>, <a href="frilmanual.html#bipunivdict">univdict</a><h3>Notes</h3> <p> A continuous universe is implemented internally using a trapezoidal itype with very steep sides, to simulate an interval. A discrete universe is represented by a dtype in which every element has membership 1. "get_univ" binds <a href="glossary.html#var">&lt;var&gt;</a> to this internal representation.</p><hr> <a name = "biphelp"> </a><h2>help  </h2><h3>Usage</h3><p> (help <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>) <br></p><h3>Description</h3><p> "help" displays help on a built-in predicate or a topic named by <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>. For a built-in predicate, this help consists of a short description of the behaviour of the predicate and the arguments it requires. The topics covered are mainly the sections of chapter 6, e.g. manipulating windows, modules, system limits etc., and the help provided is a summary  of the relevant facilities or information. The goal (help help) will display a list of the topics for which help is currently provided.</p><h3> Behaviour </h3><p>Always succeeds. If <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> names a topic for which there is no help, then the a list of the current help topics is displayed.</p><h3>Example </h3><pre>help cl <br>help help<br>help arith</pre><br><h3>See also</h3><p> <a href="frilmanual.html#biphelp_example">help_example</a><h3>Notes</h3> <p> Requires the environment variable "frhelp" to be set to the directory containing the Fril help files. This is done automatically when Fril is installed, but can be changed from the Preferences dialog on a Mac, by editing "autoexec.bat" on a DOS-based machine, or by changing shell initialisation files (e.g. .cshrc) on a Unix system. </p><hr> <a name = "biphelp_example"> </a><h2>help_example  </h2><h3>Usage</h3><p> (help_example <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>) <br></p><h3>Description</h3><p> "help_example" displays an example of the use of the built-in predicate <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>.</p><h3> Behaviour </h3><p>Always succeeds. If <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> names a built-in predicate for which there is no example, then the a list of the current help topics is displayed.</p><h3>Example </h3><pre>help_example sum</pre><br><h3>See also</h3><p> help<hr> <a name = "bipidict"> </a><h2>idict  </h2><h3>Usage</h3><p> (idict <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>) <br></p><h3>Description</h3><p> "idict" is used to check whether <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a named itype fuzzy set, or to generate the names of itype fuzzy sets defined in the knowledge base.</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is the name of an itype fuzzy set defined in the knowledge base. If <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a variable, Fril will bind it to a named itype fuzzy set (if any are defined), and will resatisfy the call if necessary.</p><h3>Example </h3><pre>(high [70:0 80:1 90:0])<br>(average [50:0 60:1 70:1 80:0]) <br>?((idict X) (pq X defined as) (p X) (pp) (fail)) <br>average defined as [50:0 60:1 70:1 80:0] <br>high defined as [70:0 80:1 90:0] <br>no</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipitype">itype</a>, <a href="frilmanual.html#bipitype_name">itype_name</a>, <a href="frilmanual.html#bipddict">ddict</a>, <a href="frilmanual.html#bipunivdict">univdict</a>, <a href="frilmanual.html#bipfsetdict">fsetdict</a>, <a href="frilmanual.html#bipitype_to_list">itype_to_list</a>, <a href="frilmanual.html#bipsys">sys</a>, <a href="frilmanual.html#bipdict">dict</a><hr> <a name = "bipif"> </a><h2>if  </h2><h3>Usage</h3><p> (if <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a> <a href="glossary.html#goal_list" target="gloss">&lt;goal_list1&gt;</a> <a href="glossary.html#goal_list" target="gloss">&lt;goal_list2&gt;</a>) <br></p><h3>Description</h3><p> "if" simulates the if ... then ... else control construct of conventional procedural languages.</p><h3> Behaviour </h3><p>"if" evaluates the goal <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a> and if this succeeds it evaluates the series of calls in <a href="glossary.html#goal_list" target="gloss">&lt;goal_list1&gt;</a> and succeeds if <a href="glossary.html#goal_list" target="gloss">&lt;goal_list1&gt;</a> succeeds. Otherwise, if goal <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a> fails, it executes the series of calls in <a href="glossary.html#goal_list" target="gloss">&lt;goal_list2&gt;</a> and succeeds if <a href="glossary.html#goal_list" target="gloss">&lt;goal_list2&gt;</a> succeeds. Otherwise "if" fails. On backtracking, only the list of goals which caused "if" to succeed in the first place (i.e. either <a href="glossary.html#goal_list" target="gloss">&lt;goal_list1&gt;</a> or <a href="glossary.html#goal_list" target="gloss">&lt;goal_list2&gt;</a> but not both) is resatisfied and if this fails "if" fails.</p><h3>Example </h3><pre>?((member N (0 1 2 3)) <br>  (if (eq N 1) ((p one man) (pp)) <br>                     ((p N men) (pp)) )<br>   (fail)) <br>prints the following: <br>0 men <br>one man <br>2 men <br>3 men <br>no </pre><br><h3>See also</h3><p> <a href="frilmanual.html#bip?"> ? </a>, <a href="frilmanual.html#biporr">orr</a>, <a href="frilmanual.html#bip!"> ! </a>, <a href="frilmanual.html#bipsnips">snips</a><hr> <a name = "bipimport"> </a><h2>import  </h2><h3>Usage</h3><p> (import <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>) <br>(import (<a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> ... <a href="glossary.html#const" target="gloss">&lt;constn&gt;</a>))</p><h3>Description</h3><p> This predicate is only relevant in the context of the construction of a module. In the first form, "import" is used to declare predicate name <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> as import. In the second form, each of the predicates <a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> to <a href="glossary.html#const" target="gloss">&lt;constn&gt;</a> is declared as import. This is necessary for all predicates for which there are no definitions in the module, but which are called by procedures in the module.</p><h3> Behaviour </h3><p>Always succeeds.</p><h3>Example </h3><pre>(see module example)</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipmodule">module</a>, <a href="frilmanual.html#bipvisible">visible</a>, <a href="frilmanual.html#bipexport">export</a>, <a href="frilmanual.html#bipdynamic">dynamic</a><h3>Notes</h3> <p> Fuzzy set definitions cannot be imported. Import declarations are exploited by the module compiler, and have no side effects outside the context of a module. This means that import declarations can be made in Fril source files prior to module compilation as a part of the program documentation. </p><hr> <a name = "bipinit_random"> </a><h2>init_random  </h2><h3>Usage</h3><p> (init_random <a href="glossary.html#num" target="gloss">&lt;num&gt;</a>) <br></p><h3>Description</h3><p> Seeds the random number generator with the value <a href="glossary.html#num" target="gloss">&lt;num&gt;</a>. Different seeds will cause different pseudo-random sequences to be generated by the built-in predicate "random".</p><h3> Behaviour </h3><p>Always succeeds.</p><h3>Example </h3><pre>init_random 22</pre><br><h3>See also</h3><p> <a href="frilmanual.html#biprandom">random</a><h3>Notes</h3> <p> The random number generator is provided by a system library, and the degree of randomness may vary from system to system.</p><hr> <a name = "bipint"> </a><h2>int  </h2><h3>Usage</h3><p> (int <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>) <br></p><h3>Description</h3><p> Checks whether <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is an integer.</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is an integer, fails otherwise.</p><h3>Example </h3><pre>((valid X) (int X) (!))<br>((valid X)<br>	(negg int X)<br>	(p X unrecognised - please type an integer)<br>	(fail))<br><br>valid Hello<br>Hello unrecognised - please type an integer<br>no<br><br>valid 22.3<br>22.3 unrecognised - please type an integer<br>no<br><br>valid 12<br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipcon">con</a>, <a href="frilmanual.html#bipnum">num</a>, <a href="frilmanual.html#bipitype">itype</a>, <a href="frilmanual.html#bipdtype">dtype</a>, <a href="frilmanual.html#bipuniv">univ</a>, <a href="frilmanual.html#bipfset">fset</a>, <a href="frilmanual.html#bipatomic">atomic</a>, <a href="frilmanual.html#bipvar">var</a>, <a href="frilmanual.html#biptruncate">truncate</a>, <a href="frilmanual.html#bipremainder">remainder</a>, <a href="frilmanual.html#bipdivision">division</a><hr> <a name = "bipintersection"> </a><h2>intersection  </h2><h3>Usage</h3><p> (intersection <a href="glossary.html#fset" target="gloss">&lt;fset1&gt;</a> <a href="glossary.html#fset" target="gloss">&lt;fset2&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>) <br>(intersection <a href="glossary.html#fset" target="gloss">&lt;fset1&gt;</a> <a href="glossary.html#fset" target="gloss">&lt;fset2&gt;</a> <a href="glossary.html#fset" target="gloss">&lt;fset3&gt;</a>)</p><h3>Description</h3><p> "intersection" generates or checks the intersection between two fuzzy sets. In the first form, <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> is bound to the intersection of the two fuzzy sets <a href="glossary.html#fset" target="gloss">&lt;fset1&gt;</a> and <a href="glossary.html#fset" target="gloss">&lt;fset2&gt;</a>; the second form is used to check that the result of intersecting fuzzy sets <a href="glossary.html#fset" target="gloss">&lt;fset1&gt;</a> and <a href="glossary.html#fset" target="gloss">&lt;fset2&gt;</a> is <a href="glossary.html#fset" target="gloss">&lt;fset3&gt;</a>.</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#fset" target="gloss">&lt;fset1&gt;</a> and <a href="glossary.html#fset" target="gloss">&lt;fset2&gt;</a> have a non-empty intersection and either the third argument is either a variable (which is bound to the result) or a fuzzy set which is identical to the result. Fails otherwise.</p><h3>Example </h3><pre>set (days (Mon Tues Weds Thurs Fri Sat Sun))<br>(weekend {Fri:0.8 Sat:1.0 Sun:1.0 Mon:0.2} days)<br>(itp1 [1:0 2:1 2.5:0])<br><br>?((intersection [0:0 1:1 2:1 3:0] itp1 X)(pp X))<br>[1:0 2:1 2.5:0]<br>yes<br><br>?((intersection [10:0 11:1 12:0] itp1 X)(pp X))<br>no<br><br>?((intersection [0:0 1:1 2:0.5 2.5:0] {1:1 2:1 3:1} X)(pp X))<br>{1:1 2:0.5}<br><br>?((intersection weekend {Thurs:0.8 Fri:1} X) (pp X))<br>{Fri:0.8}</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipunion">union</a>, <a href="frilmanual.html#bipcomplement">complement</a>, <a href="frilmanual.html#bipset_difference">set_difference</a>, <a href="frilmanual.html#bipitype">itype</a>, <a href="frilmanual.html#bipdtype">dtype</a>, <a href="frilmanual.html#bipset">set</a>, <a href="frilmanual.html#bipuniv">univ</a>, <a href="frilmanual.html#bipitype_to_list">itype_to_list</a>, <a href="frilmanual.html#bipdtype_to_list">dtype_to_list</a><h3>Notes</h3> <p> It is possible to intersect a dtype fuzzy set defined on a numerical universe with an itype fuzzy set. The result is a dtype fuzzy set (assuming there are common elements).</p><hr> <a name = "bipintok"> </a><h2>intok  </h2><h3>Usage</h3><p> (intok <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var1&gt;</a>) <br>(intok <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var1&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var2&gt;</a>)</p><h3>Description</h3><p> "intok" reads the next language token from the input stream <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a>. Tokens are constants, numbers and variables, and non-blank separators such as brackets etc. This means that lists and itypes will not be read as single items, but each bracket and each element will be read separately.<br>In the two argument form of "intok", the second variable is bound to the actual character string of the token. This may be useful when reading numbers or variables.</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a> is open, and reads the next valid token. This is bound to <a href="glossary.html#var" target="gloss">&lt;var1&gt;</a>. In the two argument form, <a href="glossary.html#var" target="gloss">&lt;var2&gt;</a> is bound to a constant corresponding to the characters of the token.</p><h3>Example </h3><pre>?((pp) (repeat) (intok stdin X) (pq X) (pspaces 3) (fail)) <br>[0:0 1:1] hello 'a string' 123.45, and(a list(with nests) VAR<br>'[' 0 : 0 1 : 1 ']' hello 'a string' 123.45 and '(' a list '(' with nests ')' _5 <br>The input would have to be stopped by typing the appropriate interrupt key. </pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipget">get</a>, <a href="frilmanual.html#bipgetb">getb</a>, getk, await_input, peek, <a href="frilmanual.html#bippeekb">peekb</a>, peekk, <a href="frilmanual.html#bipflush">flush</a>, <a href="frilmanual.html#bipclose">close</a>, <a href="frilmanual.html#bipr">r</a>, <a href="frilmanual.html#bipread">read</a>, <a href="frilmanual.html#bipread_suppterm">read_suppterm</a>, <a href="frilmanual.html#bipcscanf">cscanf</a><h3>Notes</h3> <p> "intok" fails on end_of_file.</p><hr> <a name = "bipisall"> </a><h2>isall  </h2><h3>Usage</h3><p> (isall <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> <atom1> ... <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a>) <br>i.e. (isall <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>|<a href="glossary.html#goal_list" target="gloss">goal_list</a>) </p><h3>Description</h3><p> "isall" finds all solutions to the series of goals <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a>, ... <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a>, and for each solution collects <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> appropriately instantiated to a list which is unified with <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>.</p><h3> Behaviour </h3><p>"isall" succeeds if there exists a solution to the series of calls to <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a>, ... , <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a>, corresponding to a conjunction of goals, otherwise it fails. The series of calls are repeatedly executed and for each solution the corresponding instantiation of <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is collected into a list which is bound to <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>. Initially, first argument <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> must be an uninstantiated variable which is bound to the appropriate list on completion of the isall goal. Notes The semantics of isall are almost identical to findall. A slight difference is that, for "isall", the terms collected, in the list <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>, appear in the reverse order to which they are found. Those for "findall" appear in the same order as they are found.</p><h3>Example </h3><pre>((test a b a))<br>((test d e f))<br>((test g h g))<br>?((isall L (X Y) (test X Y Z) (eq X Z)) (p L))<br>((g h) (a b))<br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bip?"> ? </a>, <a href="frilmanual.html#bipfindall">findall</a>, <a href="frilmanual.html#bipforall">forall</a><hr> <a name = "bipitype"> </a><h2>itype  </h2><h3>Usage</h3><p> (itype <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>)  <br></p><h3>Description</h3><p> Checks whether <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is an itype (named or otherwise).</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is an itype, fails otherwise.</p><h3>Example </h3><pre>(itp1 [0:0 1:1 2:0])<br>itype itp1<br>yes <br>itype [0:0 1:1 2:1 3:0]<br>yes<br>itype abc<br>no</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipcon">con</a>, <a href="frilmanual.html#bipnum">num</a>, <a href="frilmanual.html#bipint">int</a>, <a href="frilmanual.html#bipdtype">dtype</a>, <a href="frilmanual.html#bipfset">fset</a>, <a href="frilmanual.html#bipuniv">univ</a>, <a href="frilmanual.html#bipatomic">atomic</a>, <a href="frilmanual.html#bipvar">var</a>, <a href="frilmanual.html#bipitype_to_list">itype_to_list</a>, <a href="frilmanual.html#bipidict">idict</a>, <a href="frilmanual.html#bipitype_name">itype_name</a>, <a href="frilmanual.html#bipdef_itype">def_itype</a><hr> <a name = "bipitype_name"> </a><h2>itype_name  </h2><h3>Usage</h3><p> (itype_name <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> <named_itype>) <br>(itype_name <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>)<br>(itype_name <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <named_itype>) </p><h3>Description</h3><p> "itype_name" converts a constant into the itype definition named by that constant, and vice-versa. It can also be used to check that a constant names an itype. The first form binds <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> to the name of the itype <named_itype>. The second form binds <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> to the definition of the itype named by <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>. The third form checks that <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> is the name of <named_itype>.</p><h3> Behaviour </h3><p>Succeeds if the first argument names the itype definition given by the second argument, or if one argument can be instantiated to make this so.</p><h3>Example </h3><pre>(itp1 [0:0 1:1 2:0])<br>?((itype_name X itp1) (p X) (p itp1) (con X))<br>itp1 [0:0 1:1 2:0]<br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipidict">idict</a>, <a href="frilmanual.html#bipitype">itype</a>, <a href="frilmanual.html#bipuniv_name">univ_name</a>, <a href="frilmanual.html#bipfset_name">fset_name</a>, <a href="frilmanual.html#bipfset">fset</a>, <a href="frilmanual.html#bipdtype">dtype</a>, <a href="frilmanual.html#bipdtype_name">dtype_name</a>, <a href="frilmanual.html#bipitype_to_list">itype_to_list</a>, <a href="frilmanual.html#bipname">name</a>, <a href="frilmanual.html#bipstringof">stringof</a>, <a href="frilmanual.html#bipcon">con</a>, , <a href="frilmanual.html#bipdef_itype">def_itype</a><h3>Notes</h3> <p> The second and third forms require the actual name of the itype. Since Fril replaces all occurrences of a named itype with the numerical definition, the constant naming the itype is only available from built-in predicates which create symbols (e.g. name, itype_name), or from input which is processed before the defining of itype <a href="glossary.html#const">&lt;const&gt;</a>.</p><hr> <a name = "bipitype_to_freq"> </a><h2>itype_to_freq  </h2><h3>Usage</h3><p> (itype_to_freq <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> <a href="glossary.html#list" target="gloss">&lt;list&gt;</a> ) <br>(itype_to_freq <itype-fuzzy-set> <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>)</p><h3>Description</h3><p> itype_to_freq converts between an itype fuzzy set and a list of element-frequency pairs representing the least prejudiced distribution. In the first form of usage, if <a href="glossary.html#list" target="gloss">&lt;list&gt;</a> is bound to a list of k lists, each of the form (ni mi) such that ni > ni+1 for i=2. . .k and mi is in the range [0,1] for i=2,. . .,k, then <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> will be bound to an itype fuzzy set containing the vertices specified by ni with memberships given by mi . In the second form, a list of element/frequency pairs is created from the least prejudiced distributuoin corresponding to the itype fuzzy set, and this list is unified with <a href="glossary.html#term" target="gloss">&lt;term&gt;</a></p><h3> Behaviour </h3><p>Succeeds if zero or one arguments can be instantiated to make the first argument an itype fuzzy set, and the second argument a list of element-frequency pairs corresponding to the least prejudiced distribution of the fuzzy set.</p><h3>Example </h3><pre>?((itype_to_freq [0:0 1:1 2:.4 3:0] L) (p L))<br>?((itype_to_freq I ((0 0) (1 1) (2 0.4) (3 0))) (p I))</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipitype_to_list">itype_to_list</a>, <a href="frilmanual.html#bipexpected_value">expected_value</a>, <a href="frilmanual.html#bipidict">idict</a>, <a href="frilmanual.html#bipitype">itype</a>, <a href="frilmanual.html#bipitype_name">itype_name</a>, <a href="frilmanual.html#bipdef_itype">def_itype</a>, <a href="frilmanual.html#bipdtype_to_freq">dtype_to_freq</a><hr> <a name = "bipitype_to_list"> </a><h2>itype_to_list  </h2><h3>Usage</h3><p> (itype_to_list <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> <a href="glossary.html#list" target="gloss">&lt;list&gt;</a> ) <br>(itype_to_list <itype-fuzzy-set> <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>)</p><h3>Description</h3><p> itype_to_list converts between an itype fuzzy set and a list of element-membership pairs. In the first form of usage, if <a href="glossary.html#list" target="gloss">&lt;list&gt;</a> is bound to a list of k lists, each of the form (ni mi) such that ni > ni+1 for i=2. . .k and mi is in the range [0,1] for i=2,. . .,k, then <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> will be bound to an itype fuzzy set containing the vertices specified by ni with memberships given by mi . In the second form, a list of element/membership pairs is created from the itype fuzzy set, and this list is unified with <a href="glossary.html#term" target="gloss">&lt;term&gt;</a></p><h3> Behaviour </h3><p>Succeeds if zero or one arguments can be instantiated to make the first argument an itype fuzzy set, and the second argument a list of element-membership pairs composing the fuzzy set.</p><h3>Example </h3><pre>?((itype_to_list [0:0 1:1 2:.4 3:0] L) (p L))<br>((0 0) (1 1) (2 0.4) (3 0))<br>yes<br>?((itype_to_list I ((0 0) (1 1) (2 0.4) (3 0))) (p I))<br>[0:0 1:1 2:0.4 3:0]<br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipidict">idict</a>, <a href="frilmanual.html#bipitype">itype</a>, <a href="frilmanual.html#bipitype_name">itype_name</a>, <a href="frilmanual.html#bipdef_itype">def_itype</a>, <a href="frilmanual.html#bipitype_to_freq">itype_to_freq</a>, <a href="frilmanual.html#bipdtype_to_list">dtype_to_list</a><hr> <a name = "bipkb_garbage"> </a><h2>kb_garbage  </h2><h3>Usage</h3><p> (kb_garbage)  <br></p><h3>Description</h3><p> "kb_garbage" reclaims space that has been released by deleting items from the knowledge base.</p><h3> Behaviour </h3><p>Always succeeds.</p><h3>Example </h3><pre>?((kb_garbage))</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipstatistics">statistics</a>, <a href="frilmanual.html#bipcputime">cputime</a>, <a href="frilmanual.html#bipsystem_garbage">system_garbage</a><h3>Notes</h3> <p> In addition to the obvious ways in which garbage is created (e.g. delcl, kill, reload), garbage is also generated in the knowledge base by some of the built-in predicates such as supp_query, findall, isall, qs, ws, and os. Fril automatically performs a knowledge base garbage collection when it returns to top-level. The memory freed by kb_garbage is added to the Fril free space list, and is not released to the operating system.</p><hr> <a name = "bipkill"> </a><h2>kill  </h2><h3>Usage</h3><p> (kill <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>) <br>(kill <a href="glossary.html#named_fset" target="gloss">&lt;named_fset&gt;</a>)</p><h3>Description</h3><p> "kill" deletes an entire procedure definition, a fuzzy set definition or a module. The first form deletes the procedure or module named <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>. The second form deletes the definition of the fuzzy set <a href="glossary.html#named_fset" target="gloss">&lt;named_fset&gt;</a>.</p><h3> Behaviour </h3><p>Fails if <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> names a built-in predicate, otherwise succeeds. If there is no knowledge base item named <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>, "kill" has no side effect and simply succeeds.</p><h3>Example </h3><pre>?((dict X) (kill X) (fail))<br>no	% removes all procedure definitions<br>?((mdict X) (kill X) (fail))<br>no	% removes all current modules</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipdelcl">delcl</a>, <a href="frilmanual.html#bipreload">reload</a>, <a href="frilmanual.html#bipload">load</a>, <a href="frilmanual.html#bipdef_rel">def_rel</a>, <a href="frilmanual.html#bipdef_itype">def_itype</a>, <a href="frilmanual.html#bipdef_dtype">def_dtype</a>, <a href="frilmanual.html#bipset">set</a>, menu, <a href="frilmanual.html#bipdempster">dempster</a><h3>Notes</h3> <p> When a fuzzy set is deleted using "kill" and a new fuzzy set or procedure of the same name is added to the knowledge base, special care is needed. All occurrences of the fuzzy set name between its initial definition and the redefinition refer to the 'old' fuzzy set. Any occurrences of the name after the redefinition refer to the new fuzzy set (if it is reloaded as an fuzzy set), or to the constant if the definition is killed.</p><hr> <a name = "bipless"> </a><h2>less  </h2><h3>Usage</h3><p> (less <a href="glossary.html#num" target="gloss">&lt;num1&gt;</a> <a href="glossary.html#num" target="gloss">&lt;num2&gt;</a>) <br>(less <a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const2&gt;</a>) </p><h3>Description</h3><p> "less" checks the ordering of terms, either numerically (when both arguments are numbers), or lexicographically (when both arguments are constants).</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#num" target="gloss">&lt;num1&gt;</a> is numerically smaller than <a href="glossary.html#num" target="gloss">&lt;num2&gt;</a>, or if <a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> precedes <a href="glossary.html#const" target="gloss">&lt;const2&gt;</a> in standard dictionary order.</p><h3>Example </h3><pre>((greater X Y) (less Y X))<br>?((less 1 2))<br>yes <br>?((greater 1 2))<br>no<br>?((greater bcd abc))<br>yes<br>?((less bcd abc))<br>no</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipless_eq">less_eq</a>, <a href="frilmanual.html#bipeq">eq</a>, <a href="frilmanual.html#bipstricteq">stricteq</a>, <a href="frilmanual.html#biptruncate">truncate</a><hr> <a name = "bipless_eq"> </a><h2>less_eq  </h2><h3>Usage</h3><p> (less_eq <a href="glossary.html#num" target="gloss">&lt;num1&gt;</a> <a href="glossary.html#num" target="gloss">&lt;num2&gt;</a>) <br>(less_eq <a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const2&gt;</a>) </p><h3>Description</h3><p> "less_eq" checks the ordering of terms, either numerically (when both arguments are numbers), or lexicographically (when both arguments are constants).</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#num" target="gloss">&lt;num1&gt;</a> is numerically smaller than or equal to <a href="glossary.html#num" target="gloss">&lt;num2&gt;</a>, or if <a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> precedes or is equal to <a href="glossary.html#const" target="gloss">&lt;const2&gt;</a> in standard dictionary order.</p><h3>Example </h3><pre>?((less 1 2))<br>?((less_eq 1 2))<br>both succeed<br>?((less_eq 2 2))<br>succeeds, but<br>?((less 2 2))<br>fails<br></pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipless">less</a>, <a href="frilmanual.html#bipeq">eq</a>, <a href="frilmanual.html#bipstricteq">stricteq</a>, <a href="frilmanual.html#biptruncate">truncate</a><hr> <a name = "biplist"> </a><h2>list  </h2><h3>Usage</h3><p> (list all) <br>(list <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>) <br>(list <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>) <br>(list <a href="glossary.html#named_fset" target="gloss">&lt;named_fset&gt;</a>)</p><h3>Description</h3><p> "list" displays the definition of a procedure or named fuzzy set defined in the knowledge base, at the standard output. If the argument to list is the symbol "all" or an uninstantiated variable, the entire knowledge base is displayed. Otherwise, if the argument is a constant symbol, which names the procedure or fuzzy set, this is displayed. "list" does not display built-in predicates, or procedures that are defined in modules.</p><h3> Behaviour </h3><p>"list" always succeeds. If there is nothing in the knowledge base, or the constant argument is not the name of any known user procedure or fuzzy set, list prints a blank line and succeeds.</p><h3>Example </h3><pre>((append () X X)) <br>((append (H|T) L (H|S)) (append T L S)) <br>list append <br>((append () _21 _21)) <br>((append (_28| _27) _20 (_28| _30)) <br>(append _27 _20 _30))</pre><br><h3>See also</h3><p> <a href="frilmanual.html#biplistfile">listfile</a>, <a href="frilmanual.html#bipcl">cl</a><h3>Notes</h3> <p> Variables are printed in their internal format, that is to say the symbol underscore followed by one or more hexadecimal digits, e.g. "_3fc". In version 5.0, dialogs are not decompiled and a warning comment is printed.</p><hr> <a name = "biplistfile"> </a><h2>listfile  </h2><h3>Usage</h3><p> (listfile <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a> all) <br>(listfile <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>)<br>(listfile <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>)<br>(listfile <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a> <a href="glossary.html#named_fset" target="gloss">&lt;named_fset&gt;</a>) </p><h3>Description</h3><p> "listfile" displays the definition of a procedure or named fuzzy set defined in the knowledge base, to <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a>. If the second argument to listfile is the symbol "all" or an uninstantiated variable, the entire knowledge base is displayed. Otherwise, if it is a constant symbol, which names the procedure or fuzzy set, this is displayed. "listfile" does not display built-in predicates, or procedures that are defined in modules.</p><h3> Behaviour </h3><p>"listfile" always succeeds. If there is nothing in the knowledge base, or the argument <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> is not the name of any known user procedure or fuzzy set, listfile outputs a blank line to the file and succeeds. If <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a> already exists, the listing is appended to the contents of <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a>.</p><h3>Example </h3><pre>Assuming the usual definition of append, the query<br>?((listfile 'new_file.frl' append)) <br>causes the following listing to be written to file new_file.frl: <br>((append () _21 _21)) <br>((append (_28| _27) _20 (_28| _30)) <br>(append _27 _20 _30))</pre><br><h3>See also</h3><p> <a href="frilmanual.html#biplist">list</a>, <a href="frilmanual.html#bipcl">cl</a><h3>Notes</h3> <p> Variables are printed in their internal format, that is to say the symbol underscore followed by one or more hexadecimal digits, e.g. "_3fc". In version 5.0, dialogs are not decompiled and a warning comment is printed.</p><hr> <a name = "biplload"> </a><h2>lload  </h2><h3>Usage</h3><p> (lload (<a href="glossary.html#filename" target="gloss">&lt;filename1&gt;</a> ... <filenamen>))  <br></p><h3>Description</h3><p> "lload" recursively loads each of the source code or module files, named in its single list argument. Thus lload loads files in the order <a href="glossary.html#filename" target="gloss">&lt;filename1&gt;</a>, <a href="glossary.html#filename" target="gloss">&lt;filename2&gt;</a>, ... , <filenamen>.</p><h3> Behaviour </h3><p>"lload" always succeeds. If any of the files named do not exist, an error message is printed and loading continues with the file named next on the list.</p><h3>Example </h3><pre>Assuming that files expert.frl and vision.frm, are in the current directory, fs_list.frl is in the FRLIB directory, but perfect.* does not exist, <br>lload (expert fs_list vision perfect) <br>prints the following: <br>loading expert ... completed <br>loading fs_list ... completed <br>loading vision ... completed <br>loading perfect ... <br><control error 150> : unable to access file perfect (load perfect) <br>(failing goal) <br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipload">load</a>, <a href="frilmanual.html#bipreload">reload</a>, <a href="frilmanual.html#biplreload">lreload</a>, <a href="frilmanual.html#bipexists">exists</a><hr> <a name = "bipload"> </a><h2>load  </h2><h3>Usage</h3><p> (load <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a>)  <br></p><h3>Description</h3><p> "load" loads into Fril, the data in file <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a>. This data can take two forms: (i) valid Fril input, i.e. knowledge base definitions and queries, or (ii) Compiled modules. In the first case, "load" redirects Fril current input so that the system takes input from the file <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a> until end_of_file is read. At this point the current input is reset to its prior stream. When "loading" source files, any procedures defined in the file will be ADDED to procedures of the same name, that are already defined in the knowledge base. Other name clashes will generate error messages. In the second case, "load" brings a compiled module (with the ".frm" extension) into system memory, thereby allowing access, via the exported predicates, to all the procedures defined in the module. The module name is entered into the module dictionary, accessed by "mdict", and the export and visible predicates are entered into the export dictionary, accessed by "edict". If the module name, or the name of any of the export or visible predicates, is the same as any knowledge base predicate or named itype, loaded module, or predicate in the export dictionary, then the module will not load.</p><h3> Behaviour </h3><p>"load" succeeds if <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a> is a constant and names a source file that exists in the search path. Any procedures defined in the file, that are also defined as procedures in the knowledge base, will be added to the existing definitions. All procedures and named itypes, defined in the file, that are currently defined in any other way (module name, export dictionary or named fuzzy set) will cause an "illegal redefinition" error message, and the new definition will be ignored. All other definitions will simply be loaded into the knowledge base. If <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a> names a module, "load" succeeds if (i) <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a> is a constant naming a module that exists in the search path, (ii) <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a> is not the name of a currently loaded module, or the name of a procedure or named fuzzy set defined in the knowledge base, or the name of a predicate in the export dictionary, (iii) the module so loaded does not declare export or visible any predicates that have the same name as a currently loaded module, or the same name as a procedure or named fuzzy set defined in the knowledge base, or the same name as a predicate in the export dictionary. Under all other circumstances, the goal will fail and the module will not be loaded. By contrast, "reload" replaces definitions and declarations.</p><h3>Example </h3><pre> Assume that all the following files exist in the current search path: <br>kb1.frl contains definitions for clauses "clse1", "clse2" and "mod", relation "rel1", and named itype "itp1"; and mod.frm exports "clse1" and "clse3". Fril has just been invoked so that there are currently no procedure or fuzzy set definitions or any modules. <br>load kb1 <br>will add definitions to the knowledge base for "clse1", "clse2", "mod", "rel1" and "itp1". <br>load 'kb1.frl' <br>will add the same procedure definitions to the knowledge base, so that there will now be two copies of "clse1", "clse2", and "mod". The relation "rel1" will have been updated to include the effect of the supports being added in again. The named itype, "itp1", will cause an "illegal redefinition" error message. <br>load mod <br>will cause an "illegal redefinition" error message for "mod" and "clse1", and the module will not be loaded. <br>?((kill mod) (kill clse1) (load mod)) <br>will kill the existing definitions for "mod" and "clse1", and the module mod.frm will successfully load. Only the following non-variable dictionary queries will now succeed: mdict mod<br>cdict clse2<br>rdict rel1<br>idict itp1<br>edict clse1<br>edict clse3.</pre><br><h3>See also</h3><p> <a href="frilmanual.html#biplload">lload</a>, <a href="frilmanual.html#bipreload">reload</a>, <a href="frilmanual.html#biplreload">lreload</a>, <a href="frilmanual.html#bipexists">exists</a>, <a href="frilmanual.html#bipkill">kill</a>, <a href="frilmanual.html#bipaddcl">addcl</a><h3>Notes</h3> <p> If no file extension is supplied, Fril looks first for a module (with ".frm" extension), then for a source file (with ".frl" extension) and then one with no extension. The order that directories are searched is as follows: (1) current local directory, (2) all directories defined in the environment variable "frpath", (3) the library directory, defined by the environment variable "frlib". Only one file is loaded for each call to load (see "lload" for list loading), so that as soon as a file has been located, Fril will attempt to load that file, and will not look for further files. Since Fril input is redirected when loading source files, the built-in predicate "r" takes its input from <a href="glossary.html#filename">&lt;filename&gt;</a>, not the terminal. To read from the terminal while taking input from a file, the goal (read stdin <a href="glossary.html#var">&lt;var&gt;</a>) should be used, since "stdin" is always connected to the standard input stream. "load"s may be nested in Fril source files, so that input is temporarily redirected again.</p><hr> <a name = "biplreload"> </a><h2>lreload  </h2><h3>Usage</h3><p> (lreload (<a href="glossary.html#filename" target="gloss">&lt;filename1&gt;</a> ... <filenamen>))  <br></p><h3>Description</h3><p> "lreload" recursively reloads each of the source code or module files named in its single list argument. Thus lreload reloads files in the order <a href="glossary.html#filename" target="gloss">&lt;filename1&gt;</a>, <a href="glossary.html#filename" target="gloss">&lt;filename2&gt;</a>, ... , <filenamen>.</p><h3> Behaviour </h3><p>"lreload" always succeeds. If any of the files named do not exist, an error message is printed and reloading continues with the file named next on the list.</p><h3>Example </h3><pre>Assuming that files expert.frl and vision.frm, are in the current directory, fs_list.frl is in the FRLIB directory, but perfect.* does not exist, <br>lreload (expert fs_list vision perfect) <br>prints the following: <br>reloading expert ... completed <br>reloading fs_list ... completed<br> reloading vision ... completed<br> reloading perfect ... <br><control error 150> : unable to access file perfect (reload perfect) <br>(failing goal) <br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipload">load</a>, <a href="frilmanual.html#bipreload">reload</a>, <a href="frilmanual.html#biplload">lload</a>, <a href="frilmanual.html#bipexists">exists</a><hr> <a name = "bipmatch"> </a><h2>match  </h2><h3>Usage</h3><p> (match <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a>)  <br></p><h3>Description</h3><p> "match" is only used in a support evaluation context, and is the semantic unification counterpart to the built-in predicate "eq". If either <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> , <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> or both is a fuzzy set, then "match" will succeed with support calculated as the conditional support for <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> given <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a>. The order of terms is important, since the support for <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> given <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> will usually differ from the support for <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> given <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a>. This contrasts with the syntactic unification of "eq" which is symmetric. If neither term is a fuzzy set definition, match succeeds with support (1 1) if its arguments unify, and support (0 0) otherwise.</p><h3> Behaviour </h3><p>Always succeeds when it is used within queries evaluating supports. <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> and <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> are unified semantically, if possible; otherwise support is determined by a syntactic match.</p><h3>Example </h3><pre>(itp1 [1:0 2:1 3:1 4:0])<br>(itp2 [2:0 4:1 5:0])<br>(dtp1 {1:0.5 2:1 3:1 4:0.2})<br>?((supp_query ((match itp1 2)) S) (pp S))<br>(1 1)<br>yes<br>?((supp_query ((match dtp1 2)) S) (pp S))<br>(1 1)<br>yes<br>?((supp_query ((match 2 itp1)) S) (pp S))<br>(0 1)<br>yes<br>?((supp_query ((match 2 dtp1)) S) (pp S))<br>(0 1)<br>yes<br>?((supp_query ((match itp2 dtp1)) S) (pp S))<br>(0.5 0.6)<br>yes<br>?((supp_query ((match itp1 itp2)) S) (pp S))<br>(0 0.75)<br>yes<br>?((supp_query ((match 2 3)) S) (pp S))<br>(0 0)<br>yes<br>?((supp_query ((match crisp crisp)) S) (pp S))<br>(1 1)<br>yes<br>?((supp_query ((match (X|Y) (1 2 3) )) S)<br>(p X Y support S) (pp))<br>1 (2 3) support (1 1)<br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipposs_match">poss_match</a>, <a href="frilmanual.html#bippoint_match">point_match</a>, <a href="frilmanual.html#bipeq">eq</a>, <a href="frilmanual.html#bipstricteq">stricteq</a>, <a href="frilmanual.html#bipfmem"> fmem</a>, <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#biptrue">true</a><h3>Version 4 Compatibility</h3> <p> "match" implements the default semantic unification, which uses a probability-based mass assignment model. In Version 4, a possibility-based model was used. This is still available using "poss_match"</p><hr> <a name = "bipmaximise_frame"> </a><h2>maximise_frame  </h2><h3>Usage</h3><p> (maximise_frame) <br></p><h3>Description</h3><p> This predicate is only applicable to Windows 3.1 systems, where all Fril and edit windows are treated as offspring of the parent window and (for example) cannot move outside the display area defined by the parent window. "maximise_frame" expands the parent window to fill the whole screen, and allows maximum display area for Fril and edit windows. This is equivalent to clicking the "maximise" button at the top right of the window.</p><h3> Behaviour </h3><p>Always succeeds, and expands the parent window to fill the whole screen.</p><h3>Example </h3><pre>?((maximise_frame) (zoom_top_window out))<br>will give the largest possible display area on a Windows 3.1 system, and expand the top window to fill the area.</pre><br><h3>See also</h3><p> min_window_size, max_window_size, min_window_pos, max_window_pos, zoom_top_window, resize_window<h3>Notes</h3> <p> Windows 3.1 systems only.</p><hr> <a name = "bipmdict"> </a><h2>mdict  </h2><h3>Usage</h3><p> (mdict <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>)  <br></p><h3>Description</h3><p> "mdict" checks whether <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> names a module which is currently loaded into the Fril system. Thus, "mdict" contains a dictionary of all the currently loaded modules.</p><h3> Behaviour </h3><p>Succeeds when <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> either names a currently loaded module, or is a variable and there are modules currently loaded, when <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> becomes instantiated to one of the module names.</p><h3>Example </h3><pre>((list_mods) (mdict X) (pp X) (fail)) <br>((list_mods))<br>?((list_mods)) prints out the names of all currently loaded modules.</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipmodule">module</a>, <a href="frilmanual.html#bipedict">edict</a>, <a href="frilmanual.html#bipkill">kill</a>, <a href="frilmanual.html#bipsys">sys</a><h3>Notes</h3> <p> "mdict" is resatisfiable.</p><hr> <a name = "bipmodule"> </a><h2>module  </h2><h3>Usage</h3><p> (module <a href="glossary.html#filename" target="gloss">&lt;filename1&gt;</a> <a href="glossary.html#filename" target="gloss">&lt;filename2&gt;</a>)  <br></p><h3>Description</h3><p> "module" takes a file <a href="glossary.html#filename" target="gloss">&lt;filename1&gt;</a> of Fril program text, crafted into module form using "export", "import", "visible" and "dynamic" declarations as appropriate, and creates a new module file <a href="glossary.html#filename" target="gloss">&lt;filename2&gt;</a>, which is given the extension ".frm".</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#filename" target="gloss">&lt;filename1&gt;</a> exists and can be compiled into a module without generating any errors. On succeeding, the module <a href="glossary.html#filename" target="gloss">&lt;filename2&gt;</a> is present in the Fril system.</p><h3>Example </h3><pre>?((module 'prog.frl' 'prog.frm')) <br>or <br>?((module prog prog)) <br>both translate the Fril source file prog.frl into the compiled module prog.frm (assuming no errors are generated).</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipmodule_initialisation">module_initialisation</a>, <a href="frilmanual.html#bipexport">export</a>, <a href="frilmanual.html#bipimport">import</a>, <a href="frilmanual.html#bipvisible">visible</a>, <a href="frilmanual.html#bipdynamic">dynamic</a>, <a href="frilmanual.html#bipedict">edict</a>, <a href="frilmanual.html#bipmdict">mdict</a>, <a href="frilmanual.html#bipkill">kill</a><h3>Notes</h3> <p> <a href="glossary.html#filename">&lt;filename1&gt;</a> will generally have the ".frl" extension although this is not a requirement. <a href="glossary.html#filename">&lt;filename2&gt;</a> will always be given the ".frm" extension.</p><hr> <a name = "bipmodule_initialisation"> </a><h2>module_initialisation  </h2><h3>Usage</h3><p> (module_initialisation <a href="glossary.html#goal_list" target="gloss">goal_list</a>) <br></p><h3>Description</h3><p> "module_initialisation" is a keyword recognised by the module compiler, and used to set up goals for execution when a module is loaded. In normal execution, module_initialisation is exactly equivalent to the query '?'. If it appears in a file which is compiled into a module, the goals are added to a list of goals executed after the module code has been loaded. It can be used to ensure other modules are loaded, or perform initialisation of dynamic data. Note that any predicates called by a compiled "module_initialisation" goal must be either built-in predicates, or defined as import, export, visible, or dynamic within the module. </p><h3> Behaviour </h3><p>Executes the series of calls in <a href="glossary.html#goal_list" target="gloss">goal_list</a>, using the standard depth-first search mechanism. If the call is included in a file compiled to a module, the calls in <a href="glossary.html#goal_list" target="gloss">goal_list</a> are executed after the module code is loaded into the knowledge base. In this case, an error is generated if the list of goals fails.</p><h3>Example </h3><pre>?((module 'prog.frl' 'prog.frm')) <br>or <br>?((module prog prog)) <br>both translate the Fril source file prog.frl into the compiled module prog.frm (assuming no errors are generated).</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipmodule">module</a>, <a href="frilmanual.html#bipexport">export</a>, <a href="frilmanual.html#bipimport">import</a>, <a href="frilmanual.html#bipvisible">visible</a>, <a href="frilmanual.html#bipdynamic">dynamic</a>, <a href="frilmanual.html#bip?"> ? </a> <h3>Notes</h3> <p> Multiple "module_initialisation" commands can be included in a module source file. After loading the compiled module, the goals will be executed in the order in which they appeared in the sourtce file. "dialog" and "menu" commands are translated into "module_initialisation: commands by the module compiler.</p><hr> <a name = "bipname"> </a><h2>name  </h2><h3>Usage</h3><p> (name <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>) <br>(name (<a href="glossary.html#asc_int" target="gloss">&lt;asc_int1&gt;</a> <a href="glossary.html#asc_int" target="gloss">&lt;asc_int2&gt;</a> ... ) <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>) (name (<a href="glossary.html#asc_int" target="gloss">&lt;asc_int1&gt;</a> <a href="glossary.html#asc_int" target="gloss">&lt;asc_int2&gt;</a> ... ) <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>) </p><h3>Description</h3><p> "name" converts a list of ASCII integers into the constant whose print name is that series of ASCII codes, or vice- versa. Alternatively, name can be used to check that a constant is named by the string of ASCII codes given.</p><h3> Behaviour </h3><p>Succeeds when the first argument is a list of ASCII codes which form the print name of the second argument, or when instantiation of one argument causes this to be true.</p><h3>Example </h3><pre>?((name X fred) (pp X)) <br>(102 114 101 100) <br>yes <br>?((name (49 50) X) (ppq X) (int X)) <br>'12'<br>no <br>X is instantiated to the constant '12', rather than the integer 12.<br>?((name (49 50) X) (convert X XINT) (int XINT) (ppq X XINT))<br>'12'<br>12<br>yes<br></pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipstringof">stringof</a>, <a href="frilmanual.html#bipcharof">charof</a>, <a href="frilmanual.html#bipitype_name">itype_name</a>, <a href="frilmanual.html#bipdtype_name">dtype_name</a>, <a href="frilmanual.html#bipconvert">convert</a>, <a href="frilmanual.html#bipprlen">prlen</a>, <a href="frilmanual.html#bipgensym">gensym</a>, <a href="frilmanual.html#bipfset_name">fset_name</a>, <a href="frilmanual.html#bipfilename">filename</a><h3>Notes</h3> <p> It is not possible to generate numbers immediately using the built-in predicate "name". However, this can be done very easily in association with built-in predicate "convert".</p><hr> <a name = "bipneg"> </a><h2>neg  </h2><h3>Usage</h3><p> (neg <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a>)  <br></p><h3>Description</h3><p> "neg" implements the standard Fril prolog "negation as failure". The <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a> must be a callable Fril prolog goal. "neg" is similar to "negg", except that the former takes a single argument goal.</p><h3> Behaviour </h3><p>"neg" fails when a solution to <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a> has been found, and succeeds if no solution can be found.</p><h3>Example </h3><pre>Assuming append is defined so that <br>?((append (a b) (c d) L) (pp L)) succeeds printing (a b c d), then <br>?((append (a b) (c d) L) (neg (eq L (a b c))) (pp L)) <br>also succeeds printing (a b c d), whilst <br>?((append (a b) (c d) L) (neg (eq L (a b c d))) (pp L)) <br>fails. </pre><br><h3>See also</h3><p> <a href="frilmanual.html#bip?"> ? </a>, <a href="frilmanual.html#bip!"> ! </a>, <a href="frilmanual.html#bipfail">fail</a>, <a href="frilmanual.html#bipnegg">negg</a>, <a href="frilmanual.html#bipnot">not</a><hr> <a name = "bipnegg"> </a><h2>negg  </h2><h3>Usage</h3><p> (negg <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> ... <a href="glossary.html#term" target="gloss">&lt;termn&gt;</a>) <br>i.e. (negg|<a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a>) </p><h3>Description</h3><p> "negg" implements the standard Fril prolog "negation as failure". The <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a> must be a callable Fril prolog goal. "negg" has identical semantics to neg, but a slightly different syntax. "negg" is used by inserting the symbol "negg" at the front of the list representing the goal <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a> being negated. This syntax is compatible with "not" (used for support logic negation).</p><h3> Behaviour </h3><p>"negg" fails when a solution to <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a> has been found, and succeeds if no solution can be found.</p><h3>Example </h3><pre>Assuming that append is defined so that <br>?((append (a b) (c d) L) (pp L)) succeeds printing (a b c d), then <br>?((append (a b) (c d) L) (negg eq L (a b c)) (pp L))<br>also succeeds printing (a b c d), whilst <br>?((append (a b) (c d) L) (negg eq L (a b c d)) (pp L))<br>fails.</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bip?"> ? </a>, <a href="frilmanual.html#bip!"> ! </a>, <a href="frilmanual.html#bipfail">fail</a>, <a href="frilmanual.html#bipneg">neg</a>, <a href="frilmanual.html#bipnot">not</a><hr> <a name = "bipnospy"> </a><h2>nospy  </h2><h3>Usage</h3><p> (nospy all) <br>(nospy <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>) </p><h3>Description</h3><p> "nospy all", in the first form of usage, removes all spy points from predicates currently being spied. In the second form of usage, "nospy" removes the spypoint from the procedure name <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>.</p><h3> Behaviour </h3><p>Always succeeds.</p><h3>Example </h3><pre>spy first_pred <br>spy second_pred <br>?((spying X) (pp X) (fail)) <br>first_pred <br>second_pred <br>no <br>?((nospy first_pred) (nospy dummy)) <br>yes <br>?((spying X) (pp X) (fail)) <br>second_pred <br>no</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipspy">spy</a>, <a href="frilmanual.html#biptq">tq</a>, <a href="frilmanual.html#bipspying">spying</a><hr> <a name = "bipnot"> </a><h2>not  </h2><h3>Usage</h3><p> (not <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> .... <a href="glossary.html#term" target="gloss">&lt;termn&gt;</a>) <br>i.e. (not|<a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a>) </p><h3>Description</h3><p> "not" is the support logic negation operator, so that if the support for the conclusion (<a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a>...<a href="glossary.html#term" target="gloss">&lt;termn&gt;</a>) is (L U), the negated call has support (1-U 1-L).</p><h3> Behaviour </h3><p>Succeeds with support computed for the support logic negation of the goal (<a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> ... <a href="glossary.html#term" target="gloss">&lt;termn&gt;</a>). "not" always succeeds, since it is only used within queries evaluating support.</p><h3>Example </h3><pre>((reliable component)) : (0.6 0.8) <br>qs((not reliable component)) <br>((not reliable component)) : (0.2 0.4) <br>no (more) solutions <br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipor">or</a>, <a href="frilmanual.html#bipand">and</a>, <a href="frilmanual.html#bipdisj">disj</a>, <a href="frilmanual.html#bipconj">conj</a>, <a href="frilmanual.html#bipnegg">negg</a>, <a href="frilmanual.html#bipneg">neg</a>, <a href="frilmanual.html#biptrue">true</a><h3>Notes</h3> <p> For a "standard" Prolog negation (i.e. negation as failure), use "neg" or "negg". Use of "not" when Fril is not evaluating supports causes an error message to be printed.</p><hr> <a name = "bipnum"> </a><h2>num  </h2><h3>Usage</h3><p> (num <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>)  <br></p><h3>Description</h3><p> Checks whether <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a number (i.e. floating point decimal or integer).</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a number, fails otherwise.</p><h3>Example </h3><pre>((valid_input X) (num X)) <br>valid_input 23.0<br>yes<br>valid_input abc<br>no </pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipcon">con</a>, <a href="frilmanual.html#bipint">int</a>, <a href="frilmanual.html#bipitype">itype</a>, <a href="frilmanual.html#bipdtype">dtype</a>, <a href="frilmanual.html#bipfset">fset</a>, <a href="frilmanual.html#bipatomic">atomic</a>, <a href="frilmanual.html#bipvar">var</a>, <a href="frilmanual.html#bipuniv">univ</a>, <a href="frilmanual.html#biptruncate">truncate</a>, <a href="frilmanual.html#bipconvert">convert</a><hr> <a name = "bipoh"> </a><h2>oh  </h2><h3>Usage</h3><p> (oh <a href="glossary.html#goal_list" target="gloss">goal_list</a>)  <br></p><h3>Description</h3><p> "oh" executes the series of calls in <a href="glossary.html#goal_list" target="gloss">goal_list</a> using the standard depth-first mechanism, and prints the successful instantiation of <a href="glossary.html#goal_list" target="gloss">goal_list</a> on the standard output. If the query evaluation succeeds, "oh" prompts the user to respond and backtracks to find another solution if requested, otherwise it simply succeeds.</p><h3> Behaviour </h3><p>"oh" always succeeds provided that its argument is valid. <a href="glossary.html#goal_list" target="gloss">goal_list</a> is queried, and any successfully instantiated query pattern is displayed followed by the prompt "...next? (y/n)". If the response given is "n", then the goal (oh <a href="glossary.html#goal_list" target="gloss">goal_list</a>) succeeds. Any other response causes "oh" to backtrack over <a href="glossary.html#goal_list" target="gloss">goal_list</a> for another solution. If one is found the process is repeated, otherwise "oh" succeeds printing "no (more) solutions".</p><h3>Example </h3><pre>oh ((append X Y (a b c) )) <br>((append () (a b c) (a b c))<br>next? (y/n) <br>y <br>((append (a) (b c) (a b c))<br>next? (y/n) <br>n <br>no (more) solutions <br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bip?"> ? </a>, <a href="frilmanual.html#bipwh">wh</a>, <a href="frilmanual.html#bipqh">qh</a>, <a href="frilmanual.html#bipos">os</a><h3>Notes</h3> <p> "oh" is not resatisfiable, although it is possible to backtrack over <a href="glossary.html#goal_list">goal_list</a> from within the "oh" goal.</p><hr> <a name = "bipopen"> </a><h2>open  </h2><h3>Usage</h3><p> (open <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a>)  <br></p><h3>Description</h3><p> "open" opens a file for input, and associates a stream with <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a>.</p><h3> Behaviour </h3><p>Succeeds if the file exists, and the input stream is successfully opened.</p><h3>Example </h3><pre>?((open file1) (read file1 X) (pp X) (close file1)) <br>reads the first term from file1, and prints it on the screen.</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipcreate">create</a>, <a href="frilmanual.html#bipcreate_r">create_r</a>, <a href="frilmanual.html#bipcreate_ra">create_ra</a>, <a href="frilmanual.html#bipclose">close</a>, <a href="frilmanual.html#bipflush">flush</a>, file, <a href="frilmanual.html#bipfilepos">filepos</a>, <a href="frilmanual.html#bipfilesearch">filesearch</a>, <a href="frilmanual.html#bipexists">exists</a><h3>Notes</h3> <p> A stream opened with "open" can only be used for reading input.</p><hr> <a name = "bipor"> </a><h2>or  </h2><h3>Usage</h3><p> (or <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> ... <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a>)  <br></p><h3>Description</h3><p> "or" implements a Fril support logic disjunction. It accumulates the support for successive pairs of the support logic goals <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> to <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a> combining them using the support logic calculus for disjunction.</p><h3> Behaviour </h3><p>Succeeds with support equal to the support for the disjunction of goals <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> to <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a>. "or" always succeeds since it is only used within queries evaluating supports. The support for goal <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> is combined with the support for <a href="glossary.html#goal" target="gloss">&lt;goal2&gt;</a> using the default calculus for disjunction. The combined support is then further combined with the support for <a href="glossary.html#goal" target="gloss">&lt;goal3&gt;</a> and so on in recursive fashion.</p><h3>Example </h3><pre>?((supp_query ((design X Y)) S) (p X Y S '; ') (fail)) <br>des_1 ok (0.144 0.453) ; des_2 ok (0.399 0.760) ; <br>no <br>?((supp_query ((or (design X Y) (design W Z))) S)<br>	(p X Y W Z S) (pp) (fail)) <br>des_1 ok des_1 ok (0.267 0.701) <br>des_1 ok des_2 ok (0.485 0.869) <br>des_2 ok des_1 ok (0.485 0.869) <br>des_2 ok des_2 ok (0.639 0.942) <br>no</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipnot">not</a>, <a href="frilmanual.html#bipand">and</a>, <a href="frilmanual.html#biptrue">true</a>, <a href="frilmanual.html#biporr">orr</a>, <a href="frilmanual.html#bipdisj">disj</a>, <a href="frilmanual.html#bipconj">conj</a><hr> <a name = "biporr"> </a><h2>orr  </h2><h3>Usage</h3><p> (orr <a href="glossary.html#goal_list" target="gloss">&lt;goal_list1&gt;</a> ... <a href="glossary.html#goal_list" target="gloss">&lt;goal_listn&gt;</a>)  <br></p><h3>Description</h3><p> "orr" implements a standard Fril prolog disjunction using the depth search inference strategy. To prove the goal, the <a href="glossary.html#goal_list" target="gloss">goal_list</a>'s are successively queried starting with <a href="glossary.html#goal_list" target="gloss">&lt;goal_list1&gt;</a> and continuing to <a href="glossary.html#goal_list" target="gloss">&lt;goal_listn&gt;</a> until one of them is proved. If none can be proved then the call to "orr" fails.</p><h3> Behaviour </h3><p>"orr" succeeds if one or more of <a href="glossary.html#goal_list" target="gloss">&lt;goal_list1&gt;</a> to <a href="glossary.html#goal_list" target="gloss">&lt;goal_listn&gt;</a> can be proved. On backtracking, Fril attempts to reprove the <a href="glossary.html#goal_list" target="gloss">goal_list</a> that was previously proved, and then the subsequent <a href="glossary.html#goal_list" target="gloss">goal_list</a>'s in the goal. The resatisfiability of "orr" is dependent upon whether any of the <a href="glossary.html#goal_list" target="gloss">goal_list</a>'s themselves are resatisfiable, or whether more than one of the <a href="glossary.html#goal_list" target="gloss">goal_list</a>'s can be proved.</p><h3>Example </h3><pre>?((orr ((eq 1 2) (pp wrong))<br>	((eq 2 3) (p wrong again) (pp)) <br>	((eq 3 3) (p right this time) (pp))<br>	((eq 4 4) (p right again) (pp) (fail))<br>	((eq 5 5) (p and again) (pp)) ) <br>   (pp here) (fail)) <br>right this time<br>here<br>right again<br>and again<br>here<br>no</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bip?"> ? </a>, <a href="frilmanual.html#bipif">if</a>, <a href="frilmanual.html#bipor">or</a><h3>Notes</h3> <p> If, in attempting to prove an <a href="glossary.html#goal_list">goal_list</a>, a cut (!) is encountered, all backtrack points in the goal before the cut will be removed, thus preventing further solutions to the "orr" being generated by subsequent <a href="glossary.html#goal_list">goal_list</a>'s. This means that the "orr" behaves in exactly the same way as a disjunction of "n" Fril prolog clauses, that have bodies made up of <a href="glossary.html#goal_list">&lt;goal_list1&gt;</a> to <a href="glossary.html#goal_list">&lt;goal_listn&gt;</a>.</p><hr> <a name = "bipos"> </a><h2>os  </h2><h3>Usage</h3><p> (os <a href="glossary.html#goal_list" target="gloss">goal_list</a>)  <br>(os (<a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> . . . <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a>)) <br>i.e. (os (<a href="glossary.html#const" target="gloss">&lt;const&gt;</a> | <a href="glossary.html#goal_list" target="gloss">goal_list</a>))</p><h3>Description</h3><p> "os" finds the support for the conjunction of goals in <a href="glossary.html#goal_list" target="gloss">goal_list</a>, one solution at a time. "os" uses supp_query for support evaluation, so that for each possible instantiation of <a href="glossary.html#goal_list" target="gloss">goal_list</a>, all proof paths are evaluated and the supports combined. The second form of the query allows the semantic unification method to be specified for the query evaluation - <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> can be "match" (the default), "point_match", or "poss_match". "os" prints the successful instantiation of <a href="glossary.html#goal_list" target="gloss">goal_list</a> together with its computed support, at the standard output. After each solution is printed, "os" prompts the user to respond and backtracks to find another solution if requested, otherwise it succeeds printing a completion message.</p><h3> Behaviour </h3><p>"os" always succeeds provided that its argument is valid. <a href="glossary.html#goal_list" target="gloss">goal_list</a> is queried and the support evaluated, and on finding a solution, "os" prints the successfully instantiated query pattern, and associated support pair, followed by the prompt "...next? (y/n)". If the response given is "n", then the goal (os <a href="glossary.html#goal_list" target="gloss">goal_list</a>) succeeds. Any other response causes "os" to backtrack over <a href="glossary.html#goal_list" target="gloss">goal_list</a> to evaluate the support for another solution. If a solution is found the process is repeated, otherwise "os" succeeds printing "no (more) solutions".</p><h3>Example </h3><pre>((test a)) : (0.5 0.8) <br>((test b)) : (0.7 0.9) <br>os ((test X) (test Y)) </pre><br><pre>interacts with the user as follows: <br>((test a) (test a)) : (0.25 0.64) ...next ? (y/n)<br> y <br>((test a) (test b)) : (0.35 0.72) ...next ? (y/n) <br>n <br>no (more) solutions <br>yes</pre><h3>See also</h3><p> <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipws">ws</a>, <a href="frilmanual.html#bipqs">qs</a>, <a href="frilmanual.html#biposc">osc</a>, <a href="frilmanual.html#bipose">ose</a>, <a href="frilmanual.html#biposv">osv</a>, <a href="frilmanual.html#bip?"> ? </a>, <a href="frilmanual.html#bipoh">oh</a><h3>Notes</h3> <p> Although it is possible to backtrack over <a href="glossary.html#goal_list">goal_list</a> for more solutions from within the "os" goal, "os" itself is not resatisfiable.</p><hr> <a name = "biposc"> </a><h2>osc  </h2><h3>Usage</h3><p> (osc <a href="glossary.html#goal_list" target="gloss">goal_list</a>)  <br>(osc (<a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> . . . <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a>)) <br>i.e. (osc (<a href="glossary.html#const" target="gloss">&lt;const&gt;</a> | <a href="glossary.html#goal_list" target="gloss">goal_list</a>))</p><h3>Description</h3><p> "osc" finds the support for the conjunction of goals in <a href="glossary.html#goal_list" target="gloss">goal_list</a>, one solution at a time. "osc" uses the built-in predicate "supp_collect" for support evaluation, so that for each possible instantiation of <a href="glossary.html#goal_list" target="gloss">goal_list</a>, all proof paths are evaluated and the supports combined. Any fuzzy sets in the same argument position in <a href="glossary.html#goal_list" target="gloss">goal_list</a> are combined into a single expected fuzzy set and defuzzified. The second form of the query allows the semantic unification method to be specified for the query evaluation - <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> can be "match" (the default), "point_match", or "poss_match". "osc" prints the successful instantiation of <a href="glossary.html#goal_list" target="gloss">goal_list</a> together with its computed support, at the standard output. After each solution is printed, "osc" prompts the user to respond and backtracks to find another solution if requested, otherwise it succeeds printing a completion message.</p><h3> Behaviour </h3><p>"osc" always succeeds provided that its argument is valid. <a href="glossary.html#goal_list" target="gloss">goal_list</a> is queried and the support evaluated, and on finding a solution, "osc" prints the successfully instantiated query pattern, and associated support pair, followed by the prompt "...next? (y/n)". If the response given is "n", then the goal (osc <a href="glossary.html#goal_list" target="gloss">goal_list</a>) succeeds. Any other response causes "osc" to backtrack over <a href="glossary.html#goal_list" target="gloss">goal_list</a> to evaluate the support for another solution. If a solution is found the process is repeated, otherwise "osc" succeeds printing "no (more) solutions".</p><h3>Example </h3><pre>set (abcDomain  (a b c))<br>(mostlyA {a:1 b:.2} abcDomain)<br>(mostlyB {a:.3 b:1 c:.2} abcDomain)<br>((test mostlyA )) : (0.5 0.8) <br>((test mostlyB )) : (0.7 0.9) <br>osc ((test X)) <br>>>> EXAMPLE >>></pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipsupp_collect">supp_collect</a>, <a href="frilmanual.html#bip?"> ? </a>, <a href="frilmanual.html#bipos">os</a>, <a href="frilmanual.html#biposv">osv</a>, ose, <a href="frilmanual.html#bipoh">oh</a>, <a href="frilmanual.html#bipwsc">wsc</a>, <a href="frilmanual.html#bipqsc">qsc</a><h3>Notes</h3> <p> Although it is possible to backtrack over <a href="glossary.html#goal_list">goal_list</a> for more solutions from within the "osc" goal, "osc" itself is not resatisfiable.</p><hr> <a name = "bipose"> </a><h2>ose  </h2><h3>Usage</h3><p> (ose <a href="glossary.html#goal_list" target="gloss">goal_list</a>)  <br>(ose (<a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> . . . <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a>)) <br>i.e. (ose (<a href="glossary.html#const" target="gloss">&lt;const&gt;</a> | <a href="glossary.html#goal_list" target="gloss">goal_list</a>))</p><h3>Description</h3><p> "ose" finds the support for the conjunction of goals in <a href="glossary.html#goal_list" target="gloss">goal_list</a>, one solution at a time. "ose" uses the built-in predicate "supp_expect" for support evaluation, so that for each possible instantiation of <a href="glossary.html#goal_list" target="gloss">goal_list</a>, all proof paths are evaluated and the supports combined. Any fuzzy sets in the same argument position in <a href="glossary.html#goal_list" target="gloss">goal_list</a> are combined into a single expected fuzzy set. The second form of the query allows the semantic unification method to be specified for the query evaluation - <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> can be "match" (the default), "point_match", or "poss_match". "ose" prints the successful instantiation of <a href="glossary.html#goal_list" target="gloss">goal_list</a> together with its computed support, at the standard output. After each solution is printed, "ose" prompts the user to respond and backtracks to find another solution if requested, otherwise it succeeds printing a completion message.</p><h3> Behaviour </h3><p>"ose" always succeeds provided that its argument is valid. <a href="glossary.html#goal_list" target="gloss">goal_list</a> is queried and the support evaluated, and on finding a solution, "ose" prints the successfully instantiated query pattern, and associated support pair, followed by the prompt "...next? (y/n)". If the response given is "n", then the goal (ose <a href="glossary.html#goal_list" target="gloss">goal_list</a>) succeeds. Any other response causes "os" to backtrack over <a href="glossary.html#goal_list" target="gloss">goal_list</a> to evaluate the support for another solution. If a solution is found the process is repeated, otherwise "os" succeeds printing "no (more) solutions".</p><h3>Example </h3><pre>((test a)) : (0.5 0.8) <br>((test b)) : (0.7 0.9) <br>os ((test X) (test Y)) <br>interacts with the user as follows: <br>((test a) (test a)) : (0.25 0.64) ...next ? (y/n)<br> y <br>((test a) (test b)) : (0.35 0.72) ...next ? (y/n) <br>n <br>no (more) solutions <br>yes<br>>>> EXAMPLE >>></pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipsupp_expect">supp_expect</a>, <a href="frilmanual.html#bipexpected_value">expected_value</a>, <a href="frilmanual.html#bipwse">wse</a>, <a href="frilmanual.html#bipqse">qse</a>, <a href="frilmanual.html#bip?"> ? </a>, <a href="frilmanual.html#bipos">os</a>, <a href="frilmanual.html#biposv">osv</a>, <a href="frilmanual.html#biposc">osc</a>, <a href="frilmanual.html#bipoh">oh</a><h3>Notes</h3> <p> Although it is possible to backtrack over <a href="glossary.html#goal_list">goal_list</a> for more solutions from within the "ose" goal, "ose" itself is not resatisfiable.</p><hr> <a name = "biposv"> </a><h2>osv  </h2><h3>Usage</h3><p> (osv <a href="glossary.html#goal_list" target="gloss">goal_list</a>)  <br>(osv (<a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> . . . <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a>)) <br>i.e. (osv (<a href="glossary.html#const" target="gloss">&lt;const&gt;</a> | <a href="glossary.html#goal_list" target="gloss">goal_list</a>))</p><h3>Description</h3><p> "osv" finds the support for the conjunction of goals in <a href="glossary.html#goal_list" target="gloss">goal_list</a>, one solution at a time. "osv" uses the built-in predicate "supp_value" for support evaluation, so that for each possible instantiation of <a href="glossary.html#goal_list" target="gloss">goal_list</a>, all proof paths are evaluated and the supports combined. Any fuzzy sets in the same argument position in <a href="glossary.html#goal_list" target="gloss">goal_list</a> are combined into a single expected fuzzy set and defuzzified. The second form of the query allows the semantic unification method to be specified for the query evaluation - <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> can be "match" (the default), "point_match", or "poss_match". "osv" prints the successful instantiation of <a href="glossary.html#goal_list" target="gloss">goal_list</a> together with its computed support, at the standard output. After each solution is printed, "osv" prompts the user to respond and backtracks to find another solution if requested, otherwise it succeeds printing a completion message.</p><h3> Behaviour </h3><p>"osv" always succeeds provided that its argument is valid. <a href="glossary.html#goal_list" target="gloss">goal_list</a> is queried and the support evaluated, and on finding a solution, "osv" prints the successfully instantiated query pattern, and associated support pair, followed by the prompt "...next? (y/n)". If the response given is "n", then the goal (osv <a href="glossary.html#goal_list" target="gloss">goal_list</a>) succeeds. Any other response causes "osv" to backtrack over <a href="glossary.html#goal_list" target="gloss">goal_list</a> to evaluate the support for another solution. If a solution is found the process is repeated, otherwise "osv" succeeds printing "no (more) solutions".</p><h3>Example </h3><pre>((test a)) : (0.5 0.8) <br>((test b)) : (0.7 0.9) <br>os ((test X) (test Y)) <br>interacts with the user as follows: <br>((test a) (test a)) : (0.25 0.64) ...next ? (y/n)<br> y <br>((test a) (test b)) : (0.35 0.72) ...next ? (y/n) <br>n <br>no (more) solutions <br>yes<br>>>> EXAMPLE >>></pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipsupp_value">supp_value</a>, <a href="frilmanual.html#bipwsv">wsv</a>, <a href="frilmanual.html#bipqsv">qsv</a>, <a href="frilmanual.html#bip?"> ? </a>, <a href="frilmanual.html#bipos">os</a>, <a href="frilmanual.html#biposc">osc</a>, ose, <a href="frilmanual.html#bipoh">oh</a><h3>Notes</h3> <p> Although it is possible to backtrack over <a href="glossary.html#goal_list">goal_list</a> for more solutions from within the "osv" goal, "osv" itself is not resatisfiable.</p><hr> <a name = "bipp"> </a><h2>p  </h2><h3>Usage</h3><p> (p <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> .... <a href="glossary.html#term" target="gloss">&lt;termn&gt;</a>)  <br></p><h3>Description</h3><p> "p" prints its arguments on the standard output, separated by spaces. The next print operation commences immediately after the last character printed. (p) on its own prints a single space. Strings are printed without quotes, so that any control characters within a string may affect the display. Named fuzzy sets appear as definitions.</p><h3> Behaviour </h3><p>Always succeeds.</p><h3>Example </h3><pre>(fuz [0:0 1:1 2:0]) <br>?((p fred fuz "string 1")) <br>fred [0:0 1:1 2:0] string 1</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bippp">pp</a>, <a href="frilmanual.html#bippq">pq</a>, <a href="frilmanual.html#bipppq">ppq</a>, <a href="frilmanual.html#bipcprintf">cprintf</a>, <a href="frilmanual.html#bipw">w</a>, <a href="frilmanual.html#bippspaces">pspaces</a>, <a href="frilmanual.html#bipputb">putb</a><hr> <a name = "bippeek"> </a><h2>peek  </h2><h3>Usage</h3><p> (peek <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>)  <br></p><h3>Description</h3><p> "peek" examines the next non-space printing character in the input stream <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a>, and binds its ASCII code to <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>. Space and control characters are ignored. The character is NOT read, and is available to the next input operation on the stream.</p><h3> Behaviour </h3><p>If <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a> is stdin, peek waits until a valid character is input.</p><h3>Example </h3><pre>((open file1)<br>	(peek file1 X)<br>	(eq X 40)<br>	(read file1 LIST)<br>	(process LIST))<br>checks the first character in file1, and if it is an opening bracket (ASCII 40), reads the first term in the file and passes it to "process".</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bippeekb">peekb</a>, peekk, await_input, <a href="frilmanual.html#bipget">get</a>, <a href="frilmanual.html#bipgetb">getb</a>, getk, <a href="frilmanual.html#bipintok">intok</a>, <a href="frilmanual.html#bipr">r</a>, <a href="frilmanual.html#bipread">read</a>, <a href="frilmanual.html#bipflush">flush</a>, <a href="frilmanual.html#bipcscanf">cscanf</a><h3>Notes</h3> <p> "peek" fails on end of file. Note that use of peek does not change the classification of the next token read, whereas get, getb and getk can.</p><hr> <a name = "bippeekb"> </a><h2>peekb  </h2><h3>Usage</h3><p> (peekb <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>)  <br></p><h3>Description</h3><p> "peekb" examines the next character (including space and control characters) in the input stream <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a>, and binds its ASCII code to <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>. The character is NOT read, and it is available to the next input operation on the stream.</p><h3> Behaviour </h3><p>If <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a> is stdin, peekb waits until a valid character is input.</p><h3>Example </h3><pre>((skip STREAM CHAR) <br>	(peekb STREAM INCHAR) <br>	(eq INCHAR CHAR) <br>	(getb STREAM _)<br>	(skip STREAM CHAR)) <br>"skip" ignores all characters with ASCII code bound to CHAR, on the input stream bound to STREAM, and fails when a different character is detected. This character is then available to the next input operation on the stream.<br>?((skip stdin 97))<br>ignores all input until an "a" is pressed</pre><br><h3>See also</h3><p> peek, peekk, await_input, <a href="frilmanual.html#bipget">get</a>, <a href="frilmanual.html#bipgetb">getb</a>, <a href="frilmanual.html#bipintok">intok</a>, <a href="frilmanual.html#bipr">r</a>, <a href="frilmanual.html#bipread">read</a>, <a href="frilmanual.html#bipread_suppterm">read_suppterm</a>, <a href="frilmanual.html#bipflush">flush</a>, <a href="frilmanual.html#bipcscanf">cscanf</a><h3>Notes</h3> <p> "peekb" fails on end of file. Use of peekb does not change the classification of the next token read, whereas get, getb and getk can.</p><hr> <a name = "bippoint_match"> </a><h2>point_match  </h2><h3>Usage</h3><p> (point_match <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a>)  <br></p><h3>Description</h3><p> "point_match" is only used in a support evaluation context, and is a specialisation of the semantic unification mechanism. If both <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> and <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> are fuzzy sets, then "point_match" will succeed with support calculated as the point value conditional support for <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> given <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a>. The order of terms is important, since the support for <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> given <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> will differ, in general, from the support for <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> given <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a>. This contrasts with the syntactic unification of "eq" which is symmetric. If neither term is a fuzzy set definition, point_match succeeds with support (1 1) if its arguments unify, and support (0 0) otherwise.</p><h3> Behaviour </h3><p>Always succeeds when it is used within queries evaluating supports. <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> and <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> are unified using point-value semantic unification, if possible; otherwise support is determined by a syntactic match.</p><h3>Example </h3><pre>(itp1 [1:0 2:1 3:1 4:0])<br>(itp2 [2:0 4:1 5:0])<br>(dtp1 {1:0.5 2:1 3:1 4:0.2})<br>?((supp_query ((point_match itp1 2)) S) (pp S))<br>(1 1)<br>yes<br>?((supp_query ((point_match dtp1 2)) S) (pp S))<br>(1 1)<br>yes<br>?((supp_query ((point_match 2 itp1)) S) (pp S))<br>(0 0)<br>yes<br>?((supp_query ((point_match 2 dtp1)) S) (pp S))<br>(1 1) >>> and here<br>yes<br>?((supp_query ((point_match itp2 dtp1)) S) (pp S))<br> (0.5 0.6)<br>yes<br>?((supp_query ((point_match itp1 itp2)) S) (pp S))<br>(0.285375 0.285375)<br>yes<br>?((supp_query ((point_match 2 3)) S) (pp S))<br>(0 0)<br>yes<br>?((supp_query ((point_match crisp crisp)) S) (pp S))<br>(1 1)<br>yes<br>?((supp_query ((point_match (X|Y) (1 2 3) )) S)<br>(p X Y support S) (pp))<br>1 (2 3) support (1 1)<br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipposs_match">poss_match</a>, <a href="frilmanual.html#bipmatch">match</a>, <a href="frilmanual.html#bipfmem"> fmem</a>, <a href="frilmanual.html#bipeq">eq</a>, <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipget_prior">get_prior</a>, <a href="frilmanual.html#bipset">set</a><h3>Notes</h3> <p> The point value semantic unification algorithm is given in Section 3.7.4 of "Fril - Fuzzy and Evidential Reasoning in AI". A discrete approximation is used to calculate the point value in the case of itype (continuous) fuzzy sets</p><hr> <a name = "bipposs_match"> </a><h2>poss_match  </h2><h3>Usage</h3><p> (poss_match <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a>)  <br></p><h3>Description</h3><p> "poss_match " is only used in a support evaluation context, and implements the possibilistic version of semantic unification. If either <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> , <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> or both is a fuzzy set, then "poss_match " will succeed with support calculated as the possibilistic conditional support for <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> given <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a>. The order of terms is important, since the support for <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> given <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> will differ, in general, from the support for <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> given <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a>. This contrasts with the syntactic unification of "eq" which is symmetric. If neither term is an fuzzy set definition, match succeeds with support (1 1) if its arguments unify, and support (0 0) otherwise.</p><h3> Behaviour </h3><p>Always succeeds when it is used within queries evaluating supports. <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> and <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> are unified semantically, if possible, using the possibilistic semantic unification model; otherwise support is determined by a syntactic match.</p><h3>Example </h3><pre>(itp1 [1:0 2:1 3:1 4:0])<br>(itp2 [2:0 4:1 5:0])<br>(dtp1 {1:0.5 2:1 3:1 4:0.2})<br>?((supp_query ((poss_match itp1 2)) S) (pp S))<br>(1 1)<br>yes<br>?((supp_query ((poss_match dtp1 2)) S) (pp S))<br>(1 1)<br>yes<br>?((supp_query ((poss_match 2 itp1)) S) (pp S))<br>(0 1)<br>yes<br>?((supp_query ((poss_match 2 dtp1)) S) (pp S))<br>(0 1)<br>yes<br>?((supp_query ((poss_match itp2 dtp1)) S) (pp S))<br>(0 0.5)<br>yes<br>?((supp_query ((poss_match itp1 itp2)) S) (pp S))<br>(0 0.666667)<br>yes<br>?((supp_query ((poss_match 2 3)) S) (pp S))<br>(0 0)<br>yes<br>?((supp_query ((poss_match crisp crisp)) S) (pp S))<br>(1 1)<br>yes<br>?((supp_query ((poss_match (X|Y) (1 2 3) )) S)<br>(p X Y support S) (pp))<br>1 (2 3) support (1 1)<br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipmatch">match</a>, <a href="frilmanual.html#bippoint_match">point_match</a>, <a href="frilmanual.html#bipfmem"> fmem</a>, <a href="frilmanual.html#bipeq">eq</a>, <a href="frilmanual.html#bipstricteq">stricteq</a>, <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#biptrue">true</a><h3>Version 4 Compatibility</h3> <p> "poss_match " implements the possibility-based semantic unification, which was used as default in Version 4."</p><hr> <a name = "bippower"> </a><h2>power  </h2><h3>Usage</h3><p> (power <a href="glossary.html#num" target="gloss">&lt;num1&gt;</a> <a href="glossary.html#num" target="gloss">&lt;num2&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>) <br>(power <a href="glossary.html#num" target="gloss">&lt;num1&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> <a href="glossary.html#num" target="gloss">&lt;num2&gt;</a>) </p><h3>Description</h3><p> "power" is used to raise a number to the power of its exponent, or to compute the logarithm of a number with specified base. In the first form, <a href="glossary.html#num" target="gloss">&lt;num1&gt;</a> is raised to the power of <a href="glossary.html#num" target="gloss">&lt;num2&gt;</a> to produce a real result in <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>. In the second form, the logarithm of <a href="glossary.html#num" target="gloss">&lt;num2&gt;</a> to base <a href="glossary.html#num" target="gloss">&lt;num1&gt;</a> is computed to produce a real result in <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>.</p><h3> Behaviour </h3><p>Succeeds if the third argument can be made equal to the first raised to the power of the second. If the first argument is instantiated to a negative number, then the second argument must be instantiated to an integer or an error will be generated. Similarly, if the third argument is instantiated, this must be a non-negative number or an error will occur. Any other values for the arguments causes the goal to fail.</p><h3>Example </h3><pre>?((power 2 3 8)) <br>yes <br>?((power -0.16 -2 X) (p X)) <br>39.063 <br>yes <br>?((power 10 X 256) (p X)) <br>2.4082 <br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipexp">exp</a>, <a href="frilmanual.html#bipsquare">square</a>, <a href="frilmanual.html#biptimes">times</a><hr> <a name = "bippp"> </a><h2>pp  </h2><h3>Usage</h3><p> (pp <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> .... <a href="glossary.html#term" target="gloss">&lt;termn&gt;</a>)  <br></p><h3>Description</h3><p> "pp" prints each term followed by a new line on the standard output. (pp) on its own prints a new line. Strings are printed without quotes, so that any control characters within a string may affect the display. Named fuzzy sets appear as their itype or dtype definitions.</p><h3> Behaviour </h3><p>Always succeeds.</p><h3>Example </h3><pre>(fuz [0:0 1:1 2:0])<br>?((pp fred fuz "string 1"))<br>fred<br>[0:0 1:1 2:0]<br>string 1</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipp">p</a>, <a href="frilmanual.html#bippq">pq</a>, <a href="frilmanual.html#bipppq">ppq</a>, <a href="frilmanual.html#bipcprintf">cprintf</a>, <a href="frilmanual.html#bipwrite">write</a>, <a href="frilmanual.html#bippspaces">pspaces</a>, <a href="frilmanual.html#bipputb">putb</a><hr> <a name = "bipppq"> </a><h2>ppq  </h2><h3>Usage</h3><p> (ppq <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> .... <a href="glossary.html#term" target="gloss">&lt;termn&gt;</a>)  <br></p><h3>Description</h3><p> "ppq" prints each term followed by a new line on the standard output. (ppq) on its own prints a new line. A string is printed in quotes if it contains any characters that would cause it to be classified as something other than a constant, such as spaces or control characters. The name of a fuzzy set is printed, rather than its definition.</p><h3> Behaviour </h3><p>Always succeeds.</p><h3>Example </h3><pre>(fuz [0:0 1:1 2:0])<br>?((ppq fred fuz "string 1"))<br>fred<br>fuz<br>'string 1'</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipp">p</a>, <a href="frilmanual.html#bippp">pp</a>, <a href="frilmanual.html#bippq">pq</a>, <a href="frilmanual.html#bipcprintf">cprintf</a>, <a href="frilmanual.html#bipwriteq">writeq</a>, <a href="frilmanual.html#bippspaces">pspaces</a>, <a href="frilmanual.html#bipputb">putb</a><hr> <a name = "bippq"> </a><h2>pq  </h2><h3>Usage</h3><p> (pq <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> .... <a href="glossary.html#term" target="gloss">&lt;termn&gt;</a>)  <br></p><h3>Description</h3><p> "pq" prints each term followed by a space on the standard output. (pq) on its own prints a space. A string is printed in quotes if it contains any characters that would cause it to be classified as something other than a constant, such as spaces or control characters. The name of a fuzzy set is printed, rather than its definition.</p><h3> Behaviour </h3><p>Always succeeds.</p><h3>Example </h3><pre>(fuz [0:0 1:1 2:0])<br>?((pq fred fuz "string 1"))<br>fred fuz 'string 1'</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipp">p</a>, <a href="frilmanual.html#bippp">pp</a>, <a href="frilmanual.html#bipppq">ppq</a>, <a href="frilmanual.html#bipcprintf">cprintf</a>, <a href="frilmanual.html#bipwq">wq</a>, <a href="frilmanual.html#bippspaces">pspaces</a>, <a href="frilmanual.html#bipputb">putb</a><hr> <a name = "bipprlen"> </a><h2>prlen  </h2><h3>Usage</h3><p> (prlen <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>) <br>(prlen <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> <a href="glossary.html#nni" target="gloss">&lt;nni&gt;</a>) </p><h3>Description</h3><p> "prlen" reports or checks the print length of <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> which can be any term apart from a list, i.e. constant, number (real or integer), variable or fuzzy set. The print length of <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is the number of character locations that will be used when <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is printed to a stream in unquoted form. For variables, this will be the length of the internal representation, e.g. _136 which has length 4. The length of fuzzy set definitions will also account for the spaces that would be printed by Fril. "prlen" cannot be used directly on a list - this must be recursively processed using "prlen" on each element. In the first form, "prlen" binds <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> to the non-negative integer which is the print length of <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>. In the second form, "prlen" checks that <a href="glossary.html#nni" target="gloss">&lt;nni&gt;</a> is the print length of <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>.</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is anything but a list and the second argument can be unified with the print length of that <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>.</p><h3>Example </h3><pre>((list_prlen () 1)) <br>((list_prlen (X|Y) N)<br>	(prlen X NX) <br>	(sum NX 1 NX1)<br>	(list_prlen Y NY)<br>	(sum NX1 NY N)) <br>?((eq (fred 'a string' X [0:0 1:0.5 3:1] 23 45.76) L)<br>	(pp)<br>	(list_prlen L N) <br>	(pp L) <br>	(p has print length N))<br>(fred a string _23a [0:0 1:0.5 3:1] 23 45.76) <br>has print length 51 <br>yes </pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipcprintf">cprintf</a>, <a href="frilmanual.html#bipname">name</a>,, <a href="frilmanual.html#bipstringof">stringof</a><h3>Notes</h3> <p> This predicate is often used for pre-formatting Fril output before printing. This is in contrast to "cprintf" which formats as it prints. "prlen" avoids the expense of using predicate "name" and computing the length of a list.</p><hr> <a name = "bippspaces"> </a><h2>pspaces  </h2><h3>Usage</h3><p> (pspaces <a href="glossary.html#nni" target="gloss">&lt;nni&gt;</a>)  <br></p><h3>Description</h3><p> "pspaces" prints <a href="glossary.html#nni" target="gloss">&lt;nni&gt;</a> spaces on the standard output (screen), where <a href="glossary.html#nni" target="gloss">&lt;nni&gt;</a> is a non-negative integer.</p><h3> Behaviour </h3><p>"pspaces" succeeds if <a href="glossary.html#nni" target="gloss">&lt;nni&gt;</a> is zero or a larger integer, otherwise it fails.</p><h3>Example </h3><pre>?((p start) (pspaces 11) (pp finish))<br>start           finish<br>yes</pre><br><pre> </pre><h3>See also</h3><p> <a href="frilmanual.html#bipp">p</a>, <a href="frilmanual.html#bippp">pp</a>, <a href="frilmanual.html#bi<a href="frilmanual.html#bippq">pq</a>, <a href="frilmanual.html#bipppq">ppq</a>, <a href="frilmanual.html#bipcprintf">cprintf</a>, <a href="frilmanual.html#bipwspaces">wspaces</a><h3>Notes</h3> <p> "pspaces" performs the function that many Prolog systems name tab. However, the name pspaces better reflects its intended function.</p><hr> <a name = "bipputb"> </a><h2>putb  </h2><h3>Usage</h3><p> (putb <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a> <a href="glossary.html#asc_int" target="gloss">&lt;asc_int&gt;</a>)  <br></p><h3>Description</h3><p> "putb" prints the character whose ASCII code is <a href="glossary.html#asc_int" target="gloss">&lt;asc_int&gt;</a> on the output stream associated with <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a>.</p><h3> Behaviour </h3><p>Always succeeds.</p><h3>Example </h3><pre>?((p start) (putb stdout 10) (p finish))<br>start<br>finish<br>yes</pre><br><pre> </pre><h3>See also</h3><p> <a href="frilmanual.html#bipwrite">write</a>, <a href="frilmanual.html#bipwriteq">writeq</a>, <a href="frilmanual.html#bipw">w</a>, <a href="frilmanual.html#bipwq">wq</a>, <a href="frilmanual.html#bipp">p</a>, <a href="frilmanual.html#bippp">pp</a>, <a href="frilmanual.html#bi<a href="frilmanual.html#bippq">pq</a>, <a href="frilmanual.html#bipppq">ppq</a>, <a href="frilmanual.html#bipcprintf">cprintf</a>, <a href="frilmanual.html#bipflush">flush</a>, <a href="frilmanual.html#bipgetb">getb</a><h3>Notes</h3> <p> "putb" can be used to write an end-of-file character in the "middle" of a file, and this may have unintended effects.</p><hr> <a name = "bipqh"> </a><h2>qh  </h2><h3>Usage</h3><p> (qh <a href="glossary.html#goal_list" target="gloss">goal_list</a>)  <br></p><h3>Description</h3><p> "qh" executes the series of calls in <a href="glossary.html#goal_list" target="gloss">goal_list</a> using the standard depth-first search mechanism, and prints the successful instantiations of <a href="glossary.html#goal_list" target="gloss">goal_list</a> on the standard output. "qh" backtracks to find all possible solutions without any further interaction from the user, and it finally succeeds printing a completion message whether or not any solutions were found.</p><h3> Behaviour </h3><p>"qh" always succeeds provided its argument is valid. If there is no solution to the query, it simply prints the message: "no (more) solutions" and succeeds. Otherwise "qh" prints the successfully instantiated query patterns <a href="glossary.html#goal_list" target="gloss">goal_list</a> one after the other until no more solutions can be found, when the message "no (more) solutions" is printed and "qh" succeeds.</p><h3>Example </h3><pre>Assume that append and length are defined in the usual way, to append two lists together and determine the length of a list, respectively. <br>qh ((append X Y (a b c)) (length X N) (less N 2)) <br>((append () (a b c) (a b c))(length () 0)(less 0 2)) <br>((append (a) (b c) (a b c))(length (a) 1)(less 1 2)) <br>no (more) solutions <br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bip?"> ? </a>, <a href="frilmanual.html#bipoh">oh</a>, <a href="frilmanual.html#bipwh">wh</a>, <a href="frilmanual.html#bipqs">qs</a><hr> <a name = "bipqs"> </a><h2>qs  </h2><h3>Usage</h3><p> (qs <a href="glossary.html#goal_list" target="gloss">goal_list</a>)  <br>(qs (<a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> . . .<a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a>)) <br>i.e. (qs (<a href="glossary.html#const" target="gloss">&lt;const&gt;</a> | <a href="glossary.html#goal_list" target="gloss">goal_list</a>))</p><h3>Description</h3><p> "qs" finds the support for the conjunction of goals in <a href="glossary.html#goal_list" target="gloss">goal_list</a> for all possible instances of <a href="glossary.html#goal_list" target="gloss">goal_list</a>. "qs" uses supp_query for support evaluation, so that for each possible instantiation of <a href="glossary.html#goal_list" target="gloss">goal_list</a>, all proof paths are evaluated and the supports combined. The second form of the query allows the semantic unification method to be specified for the query evaluation - this can be "match" (the default), "point_match", or "poss_match". "qs" backtracks to find all possible solutions without any further interaction from the user, and for each solution prints the instantiation of <a href="glossary.html#goal_list" target="gloss">goal_list</a> together with its computed support pair, on the standard output. "qs" finally succeeds printing a completion message.</p><h3> Behaviour </h3><p>"qs" always succeeds provided its argument is valid. "qs" prints each successfully instantiated query pattern <a href="glossary.html#goal_list" target="gloss">goal_list</a> together with its computed support pair, one after the other until no more solutions can be found when a finishing message is printed and "qs" succeeds.</p><h3>Example </h3><pre>((test a)) : (0.5 0.8) <br>((test b)) : (0.7 0.9) <br>qs ((test X) (test Y)) <br>((test a) (test b)) : (0.25 0.64) <br>((test a) (test b)) : (0.35 0.72) <br>((test b) (test a)) : (0.35 0.72) <br>((test b) (test b)) : (0.49 0.81) <br>no (more) solutions <br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipws">ws</a>, <a href="frilmanual.html#bipos">os</a>, <a href="frilmanual.html#bipqse">qse</a>, <a href="frilmanual.html#bipqsv">qsv</a>, <a href="frilmanual.html#bipqsc">qsc</a>, <a href="frilmanual.html#bipqh">qh</a><hr> <a name = "bipqsc"> </a><h2>qsc  </h2><h3>Usage</h3><p> (qsc <a href="glossary.html#goal_list" target="gloss">goal_list</a>)  <br>(qsc (<a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> . . . <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a>)) <br>i.e. (qsc(<a href="glossary.html#const" target="gloss">&lt;const&gt;</a> | <a href="glossary.html#goal_list" target="gloss">goal_list</a>))</p><h3>Description</h3><p> "qsc" finds the support for the conjunction of goals in <a href="glossary.html#goal_list" target="gloss">goal_list</a> for all possible instances of <a href="glossary.html#goal_list" target="gloss">goal_list</a>. "qsc" uses supp_collect for support evaluation, so that for each possible instantiation of <a href="glossary.html#goal_list" target="gloss">goal_list</a>, all proof paths are evaluated and the supports combined. Any fuzzy sets in the same argument position in <a href="glossary.html#goal_list" target="gloss">goal_list</a> are combined into a single expected fuzzy set. The second form of the query allows the semantic unification method to be specified for the query evaluation - this can be "match" (the default), "point_match", or "poss_match". "qsc" backtracks to find all possible solutions without any further interaction from the user, and for each solution prints the instantiation of <a href="glossary.html#goal_list" target="gloss">goal_list</a> together with its computed support pair, on the standard output. "qsc" finally succeeds printing a completion message.</p><h3> Behaviour </h3><p>"qsc" always succeeds provided its argument is valid. "qsc" prints each successfully instantiated query pattern <a href="glossary.html#goal_list" target="gloss">goal_list</a> together with its computed support pair, one after the other until no more solutions can be found when the message "no (more) solutions" is printed and "qsc" succeeds.</p><h3>Example </h3><pre>((test a)) : (0.5 0.8) <br>((test b)) : (0.7 0.9) <br>qs ((test X) (test Y)) <br>((test a) (test b)) : (0.25 0.64) <br>((test a) (test b)) : (0.35 0.72) <br>((test b) (test a)) : (0.35 0.72) <br>((test b) (test b)) : (0.49 0.81) <br>no (more) solutions <br>yes<br>>> EXAMPLE</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipsupp_collect">supp_collect</a>, <a href="frilmanual.html#bipqs">qs</a>, <a href="frilmanual.html#bipqse">qse</a>, <a href="frilmanual.html#bipqsv">qsv</a>, <a href="frilmanual.html#bipwsc">wsc</a>, <a href="frilmanual.html#biposc">osc</a>, <a href="frilmanual.html#bipqh">qh</a><h3>Notes</h3> <p> Although it is possible to backtrack over <a href="glossary.html#goal_list">goal_list</a> for more solutions from within the "qsc" goal, "qsc" itself is not resatisfiable.</p><hr> <a name = "bipqse"> </a><h2>qse  </h2><h3>Usage</h3><p> (qse <a href="glossary.html#goal_list" target="gloss">goal_list</a>)  <br>(qse (<a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> . . . <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a>)) <br>i.e. (qse(<a href="glossary.html#const" target="gloss">&lt;const&gt;</a> | <a href="glossary.html#goal_list" target="gloss">goal_list</a>))</p><h3>Description</h3><p> "qse" finds the support for the conjunction of goals in <a href="glossary.html#goal_list" target="gloss">goal_list</a> for all possible instances of <a href="glossary.html#goal_list" target="gloss">goal_list</a>. "qse" uses supp_expect for support evaluation, so that for each possible instantiation of <a href="glossary.html#goal_list" target="gloss">goal_list</a>, all proof paths are evaluated and the supports combined. Any fuzzy sets in the same argument position in <a href="glossary.html#goal_list" target="gloss">goal_list</a> are combined into a single expected fuzzy set. The second form of the query allows the semantic unification method to be specified for the query evaluation - this can be "match" (the default), "point_match", or "poss_match". "qse" backtracks to find all possible solutions without any further interaction from the user, and for each solution prints the instantiation of <a href="glossary.html#goal_list" target="gloss">goal_list</a> together with its computed support pair, on the standard output. "qs" finally succeeds printing a completion message.</p><h3> Behaviour </h3><p>"qse" always succeeds provided its argument is valid. "qse" prints each successfully instantiated query pattern <a href="glossary.html#goal_list" target="gloss">goal_list</a> together with its computed support pair, one after the other until no more solutions can be found when the message "no (more) solutions" is printed and "qse" succeeds.</p><h3>Example </h3><pre>((test a)) : (0.5 0.8) <br>((test b)) : (0.7 0.9) <br>qs ((test X) (test Y)) <br>((test a) (test b)) : (0.25 0.64) <br>((test a) (test b)) : (0.35 0.72) <br>((test b) (test a)) : (0.35 0.72) <br>((test b) (test b)) : (0.49 0.81) <br>no (more) solutions <br>yes<br>>> EXAMPLE</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipsupp_expect">supp_expect</a>, <a href="frilmanual.html#bipexpected_value">expected_value</a>, <a href="frilmanual.html#bipqsc">qsc</a>, <a href="frilmanual.html#bipqsv">qsv</a>, ose, <a href="frilmanual.html#bipwse">wse</a>, <a href="frilmanual.html#bipqs">qs</a>, <a href="frilmanual.html#bipqh">qh</a><h3>Notes</h3> <p> Although it is possible to backtrack over <a href="glossary.html#goal_list">goal_list</a> for more solutions from within the "qse" goal, "qse" itself is not resatisfiable.</p><hr> <a name = "bipqsv"> </a><h2>qsv  </h2><h3>Usage</h3><p> (qsv<a href="glossary.html#goal_list" target="gloss">goal_list</a>)  <br>(qsv (<a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> . . . <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a>)) <br>i.e. (qsv (<a href="glossary.html#const" target="gloss">&lt;const&gt;</a> | <a href="glossary.html#goal_list" target="gloss">goal_list</a>))</p><h3>Description</h3><p> "qsv" finds the support for the conjunction of goals in <a href="glossary.html#goal_list" target="gloss">goal_list</a> for all possible instances of <a href="glossary.html#goal_list" target="gloss">goal_list</a>. "qsv" uses supp_defuz for support evaluation, so that for each possible instantiation of <a href="glossary.html#goal_list" target="gloss">goal_list</a>, all proof paths are evaluated and the supports combined. Any fuzzy sets in the same argument position in <a href="glossary.html#goal_list" target="gloss">goal_list</a> are combined into a single expected fuzzy set and defuzzified. The second form of the query allows the semantic unification method to be specified for the query evaluation - this can be "match" (the default), "point_match", or "poss_match". "qsv" backtracks to find all possible solutions without any further interaction from the user, and for each solution prints the instantiation of <a href="glossary.html#goal_list" target="gloss">goal_list</a> together with its computed support pair, on the standard output. "qsv" finally succeeds printing a completion message.</p><h3> Behaviour </h3><p>"qsv" always succeeds provided its argument is valid. "qse" prints each successfully instantiated query pattern <a href="glossary.html#goal_list" target="gloss">goal_list</a> together with its computed support pair, one after the other until no more solutions can be found when the message "no (more) solutions" is printed and "qsv" succeeds.</p><h3>Example </h3><pre>((test a)) : (0.5 0.8) <br>((test b)) : (0.7 0.9) <br>qs ((test X) (test Y)) <br>((test a) (test b)) : (0.25 0.64) <br>((test a) (test b)) : (0.35 0.72) <br>((test b) (test a)) : (0.35 0.72) <br>((test b) (test b)) : (0.49 0.81) <br>no (more) solutions <br>yes<br>>> EXAMPLE</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipsupp_value">supp_value</a>, <a href="frilmanual.html#biposv">osv</a>, <a href="frilmanual.html#bipwsv">wsv</a>, <a href="frilmanual.html#bipqs">qs</a>, <a href="frilmanual.html#bipqse">qse</a>, <a href="frilmanual.html#bipqsc">qsc</a>,  <a href="frilmanual.html#bipqh">qh</a><h3>Notes</h3> <p> Although it is possible to backtrack over <a href="glossary.html#goal_list">goal_list</a> for more solutions from within the "qsv" goal, "qsv" itself is not resatisfiable.</p><hr> <a name = "bipr"> </a><h2>r  </h2><h3>Usage</h3><p> (r <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>) <br></p><h3>Description</h3><p> "r" reads the next term from the current Fril input stream, and binds it to <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>.</p><h3> Behaviour </h3><p>If a term is available, "r" succeeds immediately. Otherwise, if the current Fril input stream is a terminal and nothing is in the input buffer, "r" waits for a term to be typed. </p><h3>Example </h3><pre>?((r X) (p term input was X) (pp)) <br>fred <br>term input was fred <br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipread">read</a>, <a href="frilmanual.html#bipread_suppterm">read_suppterm</a>, <a href="frilmanual.html#bipflush">flush</a>, <a href="frilmanual.html#bipcscanf">cscanf</a>, <a href="frilmanual.html#bipgetb">getb</a>, <a href="frilmanual.html#bipget">get</a>, getk, <a href="frilmanual.html#bipintok">intok</a>, await_input<h3>Notes</h3> <p> "r" fails on end_of_file. The number of characters that are held in the input buffer is dependent on the operating system. The current Fril input stream is changed by the "load" and "reload" built-in predicates. Thus, if a file contains a query involving the execution of "r", and that file is loaded, "r" will read the next term from the file, not the terminal. To avoid this problem, use "read", which takes its input from a specified stream.</p><hr> <a name = "biprandom"> </a><h2>random  </h2><h3>Usage</h3><p> (random <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>) <br></p><h3>Description</h3><p> "random" generates pseudorandom floating point numbers in the range 0 to 1.</p><h3> Behaviour </h3><p>Always succeeds.</p><h3>Example </h3><pre>qh((random X))<br>((random 0.513871))<br>/* rand_list I L creates a list L of I random numbers */<br>((rand_list 0 ()) (!))<br>((rand_list C (R|T)) (random R) (sum C1 1 C) (rand_list C1 T)) <br><br>?((rand_list 5 X)(pp X))<br>(0.702231 0.226417 0.494766 0.124699 0.0838954)<br>yes<br>?((rand_list 5 X)(pp X))<br>(0.38963 0.27723 0.368053 0.983459 0.535386)<br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipinit_random">init_random</a>, <a href="frilmanual.html#bipgensym">gensym</a><h3>Notes</h3> <p> The random number generator is provided by a system library, and the degree of randomness may vary from system to system.</p><hr> <a name = "biprdict"> </a><h2>rdict  </h2><h3>Usage</h3><p> (rdict <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>) <br></p><h3>Description</h3><p> "rdict" generates or checks relation names.</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> can be unified with the name of a Fril relation in the knowledge base. If <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a variable, "rdict" is resatisfiable.</p><h3>Example </h3><pre>?((rdict X) (pp X) (fail)) <br>prints all the relation names in the knowledge base. <br>(fuey [2:0, 5:0.7, 8:1]) <br>dempster dag <br>((dag X) (loro X)) : (0.8 1) <br>((dag X) (pedro X)) : (1 1) <br>(loro (span) (raul) ... ) ... <br>((pedro X) ... ) ... <br>?((member X (fuey dag loro pedro))<br>	if (rdict X) ((p X yes)) ((p X no)) ) <br>	(p '; ')<br>	(fail)) <br>fuey no; dag no; loro yes; pedro no; no</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipdict">dict</a>, <a href="frilmanual.html#bipdef_rel">def_rel</a>, <a href="frilmanual.html#bipcl">cl</a>, <a href="frilmanual.html#bipsys">sys</a>, <a href="frilmanual.html#bipcdict">cdict</a><hr> <a name = "bipread"> </a><h2>read  </h2><h3>Usage</h3><p> (read <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>) <br></p><h3>Description</h3><p> "read" reads the next term from the input stream <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a>, and binds it to <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>.</p><h3> Behaviour </h3><p>If a term is available, read succeeds immediately. Otherwise (e.g. if <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a> is stdin), read waits for a term to be input. </p><h3>Example </h3><pre>If the file "fred" contains <br>hello (list of terms) <br>the query <br>?((open fred) (read fred X) (read fred Y) (pp X Y)) <br>produces <br>hello <br>(list of terms)<br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipr">r</a>, <a href="frilmanual.html#bipread_suppterm">read_suppterm</a>, <a href="frilmanual.html#bipflush">flush</a>, <a href="frilmanual.html#bipcscanf">cscanf</a>, <a href="frilmanual.html#bipgetb">getb</a>, <a href="frilmanual.html#bipget">get</a>, getk, <a href="frilmanual.html#bipintok">intok</a>, await_input<h3>Notes</h3> <p> "read" fails on end_of_file.</p><hr> <a name = "bipread_suppterm"> </a><h2>read_suppterm  </h2><h3>Usage</h3><p> (read_suppterm <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var1&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var2&gt;</a>) <br></p><h3>Description</h3><p> "read_suppterm" reads the next term and a support from the input stream <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a>, and binds the term to <a href="glossary.html#var" target="gloss">&lt;var1&gt;</a> and the support to <a href="glossary.html#var" target="gloss">&lt;var2&gt;</a>. If an <end-of-line> character is read before a support is found, <a href="glossary.html#var" target="gloss">&lt;var2&gt;</a> is bound to ((1 1)(0 1)).</p><h3> Behaviour </h3><p>If a term is available, read_suppterm succeeds immediately. Otherwise (e.g. if <a href="glossary.html#in_stream" target="gloss">&lt;in_stream&gt;</a> is stdin), read_suppterm waits for input. </p><h3>Example </h3><pre>If the file "fred" contains<br>hello : (0.4 0.8)<br>(list of terms) : 0.7<br>unsupported allegation<br>and is opened using the query <br>?((open fred))<br>then repeated execution of the query<br>?((read_suppterm fred X S) (p X with support S)) <br>produces<br>hello with support (0.4 0.8)<br>(list of terms) with support 0.7<br>unsupported with support ((1 1) (0 1))<br>allegation with support ((1 1) (0 1))</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipr">r</a>, <a href="frilmanual.html#bipread">read</a>, <a href="frilmanual.html#bipflush">flush</a>, <a href="frilmanual.html#bipcscanf">cscanf</a>, <a href="frilmanual.html#bipgetb">getb</a>, <a href="frilmanual.html#bipget">get</a>, getk, <a href="frilmanual.html#bipintok">intok</a>, await_input<h3>Notes</h3> <p> "read_suppterm" fails on end_of_file. This predicate can be used to simulate a Fril top level, and is particularly useful for reading clauses with variable supports.</p><hr> <a name = "bipreload"> </a><h2>reload  </h2><h3>Usage</h3><p> (reload <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a>) <br></p><h3>Description</h3><p> "reload" transfers into Fril, the data in file <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a>. This data can take two forms: (i) Fril valid input, i.e. knowledge base definitions and queries, or (ii) Compiled modules. In the first case, "reload" redirects Fril current input so that the system takes input from the file <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a> until end_of_file is read. At this point the current input is reset to its prior stream. When "reloading" source files, any procedures and named fuzzy sets defined in the file will REPLACE items of the same name that have already been defined in Fril (i.e. procedures, named fuzzy sets, modules and predicates in the export dictionary), and the new definitions will be stored in the knowledge base. In the second case, "reload" brings a compiled module (with the ".frm" extension) into system memory, thereby allowing access, via the export predicates, to all the procedures defined in the module. The module name is entered into the module dictionary, accessed by "mdict", and the export and visible predicates are entered into the export dictionary, accessed by "edict". Any existing knowledge base procedures, named fuzzy sets, loaded modules or predicates in the export dictionary, which have the same name as the new module or any predicates which it exports or makes visible, will be replaced. </p><h3> Behaviour </h3><p>"reload" succeeds if <a href="glossary.html#filename" target="gloss">&lt;filename&gt;</a> is a constant and names a file (source file or module) that exists in the search path. In contrast to "load", any definitions input in this way will REPLACE existing definitions and declarations in the knowledge base. By contrast, "load" tries to add to the existing definitions. </p><h3>Example </h3><pre>Assume that all the following files exist in the current search path: kb1.frl contains definitions for clauses "clse1", "clse2" and "mod", relation "rel1", and named itype "itp1"; kb2.frl contains definitions for "clse1" and relation "rel1"; and mod.frm exports "clse1" and "clse3". Fril has just been invoked so that there are currently no procedure or fuzzy set definitions or any modules. reload kb1 will add definitions for "clse1", "clse2", "mod", "rel1" and "itp1" to the knowledge base. reload 'kb2.frl' will replace the definitions for "clse1" and "rel1" by those contained in the file kb2.frl. All other definitions will remain the same. reload mod will reload the module mod.frm, and in so doing will delete from the knowledge base the procedure definitions for "clse1" and "mod". Only the following non-variable dictionary queries will now succeed: "mdict mod", "cdict clse2", "rdict rel1", "idict itp1", "edict clse1" and "edict clse3". reload kb2 will remove "clse1" from the export dictionary and add a new definition of the predicate to the knowledge base, and replace the existing definition of "rel1" with a new one. Now, only the following non-variable dictionary queries will succeed: "mdict mod", "cdict clse1", "cdict clse2", "rdict rel1", "idict itp1" and "edict clse3". reload kb1 will kill the module mod.frm altogether in order to add the new definition for "mod" to the knowledge base, and this in turn will remove the predicate "clse3" from the export dictionary. The definitions for "clse1" and "rel1" will be replaced with new definitions. Now, only the following non-variable dictionary queries will succeed: "cdict clse1", "cdict clse2", "rdict rel1", "idict itp1"</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipload">load</a>, <a href="frilmanual.html#biplload">lload</a>, <a href="frilmanual.html#biplreload">lreload</a>, <a href="frilmanual.html#bipexists">exists</a>, <a href="frilmanual.html#bipkill">kill</a><h3>Notes</h3> <p> If no file extension is supplied, Fril looks first for a module (with ".frm" extension), then for a source file (with ".frl" extension) and then one with no extension. The order that directories are searched is as follows: (1) current local directory, (2) all directories defined in the environment variable "frpath", (3) the library directory, defined by the environment variable "frlib". Only one file is reloaded for each call to reload (see "lreload" for list reloading), so that as soon as a file has been located, Fril will attempt to reload that file, and will not look for further files. Since Fril input is redirected when reloading source files, the built-in predicate "r" takes its input from <a href="glossary.html#filename">&lt;filename&gt;</a>, not the terminal. To read from the terminal while taking input from a file, the goal (read stdin <a href="glossary.html#var">&lt;var&gt;</a>) should be used, since "stdin" is always connected to the standard input stream. "reload"s may be nested in Fril source files, so that input is temporarily redirected again.</p><hr> <a name = "bipremainder"> </a><h2>remainder  </h2><h3>Usage</h3><p> (remainder <a href="glossary.html#num" target="gloss">&lt;num1&gt;</a> <a href="glossary.html#num" target="gloss">&lt;num2&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>) <br></p><h3>Description</h3><p> "remainder" checks or computes <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> as the remainder on dividing <a href="glossary.html#num" target="gloss">&lt;num1&gt;</a> by <a href="glossary.html#num" target="gloss">&lt;num2&gt;</a>. If <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a variable, then it will be bound to that value. <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> should be equal to <a href="glossary.html#num" target="gloss">&lt;num1&gt;</a> - <a href="glossary.html#num" target="gloss">&lt;num2&gt;</a>*trunc(<a href="glossary.html#num" target="gloss">&lt;num1&gt;</a>/<a href="glossary.html#num" target="gloss">&lt;num2&gt;</a>), where "trunc" denotes rounding down to the nearest integer.</p><h3> Behaviour </h3><p>"remainder" will succeed if <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> will unify with the remainder obtained from dividing <a href="glossary.html#num" target="gloss">&lt;num1&gt;</a> by <a href="glossary.html#num" target="gloss">&lt;num2&gt;</a>, otherwise it will fail.</p><h3>Example </h3><pre>?((remainder 19 5 X) (pp X)) returns 4 <br>?((remainder 19 5.0 X) (pp X)) returns 4 <br>?((remainder 19.0 5 X) (pp X)) returns 4 <br>?((remainder 19.4 4.9 X) (pp X)) returns 4.7</pre><br><h3>See also</h3><p> <a href="frilmanual.html#biptimes">times</a>, <a href="frilmanual.html#biptruncate">truncate</a>, <a href="frilmanual.html#bipint">int</a>, <a href="frilmanual.html#bipdivision">division</a><hr> <a name = "biprepeat"> </a><h2>repeat  </h2><h3>Usage</h3><p> (repeat) <br></p><h3>Description</h3><p> "repeat" provides a simple mechanism for iteration through backtracking.</p><h3> Behaviour </h3><p>Always succeeds. Infinitely resatisfiable. </p><h3>Example </h3><pre>((integ 0))<br>((integ X) (integ Y) (sum Y 1 X))<br>?((repeat) (integ N) (p N '') (less_eq 5 N))<br>0 1 2 3 4 5 <br>yes<br>?((create file1) (repeat) (read stdin X) (write file1 X) (eq X '.') (close file1)) <br>opens file "file1", reads terms from the standard input and writes each on a new line in "file1", until a full stop is typed. Finally "file1" is closed.</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bip?"> ? </a>, <a href="frilmanual.html#bipfail">fail</a>, <a href="frilmanual.html#bip!"> ! </a>, <a href="frilmanual.html#bipsnips">snips</a><h3>Notes</h3> <p> The combination (repeat) ... (fail) can be used to cycle endlessly, simulating a Fril interpreter for example. More frequently "repeat" is used in combination with a "conditional fail", as illustrated below.</p><hr> <a name = "bipsc"> </a><h2>sc  </h2><h3>Usage</h3><p> (sc <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a>) <br>(sc <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>)</p><h3>Description</h3><p> "sc" is a support logic meta-predicate which succeeds with the support for goal <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a>, executed using the supp_collect querying mechanism. Solutions containing fuzzy sets are combiend using the expected fuzzy set >>> BWP</p><h3> Behaviour </h3><p></p><h3>Example </h3><pre></pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsupp_collect">supp_collect</a>, <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipse">se</a>, <a href="frilmanual.html#bipsv">sv</a>, <a href="frilmanual.html#bipqsc">qsc</a>, <a href="frilmanual.html#bipwsc">wsc</a>, <a href="frilmanual.html#biposc">osc</a>, <a href="frilmanual.html#bip?"> ? </a><hr> <a name = "bipse"> </a><h2>se  </h2><h3>Usage</h3><p> (se <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a>) <br>(se <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>)</p><h3>Description</h3><p> "se" is a support logic meta-predicate which succeeds with the support for goal <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a>, executed using the supp_expect querying mechanism. Solutions containing fuzzy sets are combiend using the expected fuzzy set >>> TO BE CONTINUED **</p><h3> Behaviour </h3><p></p><h3>Example </h3><pre>>>> EXAMPLE >>></pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsupp_expect">supp_expect</a>, <a href="frilmanual.html#bipexpected_value">expected_value</a>, <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipsc">sc</a>, <a href="frilmanual.html#bipsv">sv</a>, <a href="frilmanual.html#bipqse">qse</a>, <a href="frilmanual.html#bipwse">wse</a>, ose, <a href="frilmanual.html#bip?"> ? </a><hr> <a name = "bipset"> </a><h2>set  </h2><h3>Usage</h3><p> set (<a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#num" target="gloss">&lt;num1&gt;</a> <a href="glossary.html#num" target="gloss">&lt;num2&gt;</a> )) <br>set (<a href="glossary.html#const" target="gloss">&lt;const&gt;</a> (<elem1> <elem2> . . . <elemn>))<br>where <elemi> is a constant or number and <a href="glossary.html#num" target="gloss">&lt;num1&gt;</a> is less than <a href="glossary.html#num" target="gloss">&lt;num2&gt;</a><br>(set <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> neg_inf <a href="glossary.html#num" target="gloss">&lt;num2&gt;</a>)<br>(set <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#num" target="gloss">&lt;num2&gt;</a> pos_inf )</p><h3>Description</h3><p> "set" defines a universe for fuzzy sets. The universe may be a continuous interval (first case shown above) or a discrete set (second case). Open intervals may be represented using the third and fourth cases, where pos_inf and neg_inf refer to positive infinity and negative infinity respectively.</p><h3> Behaviour </h3><p>Succeeds when the named universe can be added to the knowledge base. Fails when <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> already names an item in the knowledge base, or when there is an error in the set specification e.g. <a href="glossary.html#num" target="gloss">&lt;num1&gt;</a> is not less than <a href="glossary.html#num" target="gloss">&lt;num2&gt;</a> or an element is not a constant or number.</p><h3>Example </h3><pre>set (drinks (cola beer wine vodka))<br>set (sizes 0 100)<br>set (positives 0 pos_inf)<br>set (negatives neg_inf 0)<br>(small_size [0:0 10:1 20:1 30:0] sizes)<br>(very_small_size [0:1 10:1 20:0] sizes)<br>(refreshing_drink {cola:0.9 beer:1.0 wine:0.2} drinks)</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipuniv">univ</a>, <a href="frilmanual.html#bipunivdict">univdict</a>, <a href="frilmanual.html#bipitype">itype</a>, <a href="frilmanual.html#bipdtype">dtype</a>, <a href="frilmanual.html#bipdef_itype">def_itype</a>, <a href="frilmanual.html#bipdef_dtype">def_dtype</a>, <a href="frilmanual.html#bipget_univ">get_univ</a>, <a href="frilmanual.html#bipget_prior">get_prior</a><h3>Notes</h3> <p> A continuous universe is implemented internally using a trapezoidal itype with very steep sides, to simulate an interval. A discrete universe is represented by a dtype in which every element has membership 1.</p><hr> <a name = "bipsetenv"> </a><h2>setenv  </h2><h3>Usage</h3><p> (setenv <a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const2&gt;</a>) <br></p><h3>Description</h3><p> "setenv" is used to set the value of the environment variable <a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> to <a href="glossary.html#const" target="gloss">&lt;const2&gt;</a>. The values of environment variables can be retrieved using "getenv".</p><h3> Behaviour </h3><p>Succeeds if the value of the environment variable <a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> can be set to <a href="glossary.html#const" target="gloss">&lt;const2&gt;</a>.</p><h3>Example </h3><pre>?((setenv frlib "MacHD:Fril:Fril Library"))<br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipgetenv">getenv</a>, <a href="frilmanual.html#bipcd">cd</a><h3>Notes</h3> <p> This predicate is primarily provided for use on the Macintosh, where there is no notion of a system-wide environment. It is particularly useful for setting up frlib, etc. in a fril.boot file.</p><hr> <a name = "bipset_difference"> </a><h2>set_difference  </h2><h3>Usage</h3><p> (set_difference<a href="glossary.html#fset" target="gloss">&lt;fset1&gt;</a> <a href="glossary.html#fset" target="gloss">&lt;fset2&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>) <br>(set_difference<a href="glossary.html#fset" target="gloss">&lt;fset1&gt;</a> <a href="glossary.html#fset" target="gloss">&lt;fset2&gt;</a> <a href="glossary.html#fset" target="gloss">&lt;fset3&gt;</a>)</p><h3>Description</h3><p> "set_difference" generates or checks the set difference of two fuzzy sets. In the first form, <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> is bound to the set difference of the two fuzzy sets <a href="glossary.html#fset" target="gloss">&lt;fset1&gt;</a> and <a href="glossary.html#fset" target="gloss">&lt;fset2&gt;</a>; the second form is used to check that the result of taking the set difference of fuzzy sets <a href="glossary.html#fset" target="gloss">&lt;fset1&gt;</a> and <a href="glossary.html#fset" target="gloss">&lt;fset2&gt;</a> is <a href="glossary.html#fset" target="gloss">&lt;fset3&gt;</a>.</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#fset" target="gloss">&lt;fset1&gt;</a> and <a href="glossary.html#fset" target="gloss">&lt;fset2&gt;</a> have a non-empty set difference and either the third argument is either a variable (which is bound to the result) or a fuzzy set which is identical to the result. Fails otherwise.</p><h3>Example </h3><pre>set (days (Mon Tues Weds Thurs Fri Sat Sun))<br>(weekend {Fri:0.8 Sat:1.0 Sun:1.0 Mon:0.2} days)<br>(itp1 [1:0 2:1 2.5:0])<br><br>?((set_difference [0:0 1:1 2:1 3:0] itp1 X)(pp X))<br>[0:0 1:1 2:0]<br>yes<br><br>?((set_difference [10:0 11:1 12:0] itp1 X)(pp X))<br>no<br><br>?((set_difference [0:0 1:1 2:0.5 2.5:0] {1:1 2:1 3:1} X)(pp X))<br>no<br><br>?((set_difference weekend {Thurs:0.8 Fri:1} X) (pp X))<br>{Sat:1 Sun:1 Mon:0.2}<br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipunion">union</a>, <a href="frilmanual.html#bipcomplement">complement</a>, <a href="frilmanual.html#bipintersection">intersection</a>, <a href="frilmanual.html#bipitype">itype</a>, <a href="frilmanual.html#bipdtype">dtype</a>, <a href="frilmanual.html#bipset">set</a>, <a href="frilmanual.html#bipuniv">univ</a>, <a href="frilmanual.html#bipitype_to_list">itype_to_list</a>, <a href="frilmanual.html#bipdtype_to_list">dtype_to_list</a><h3>Notes</h3> <p> It is not possible to find the set difference between a dtype fuzzy set and an itype fuzzy set. </p><hr> <a name = "bipsh"> </a><h2>sh  </h2><h3>Usage</h3><p> (sh <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>) <br></p><h3>Description</h3><p> "sh" passes its argument to the operating system as a command to be executed.</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> is a valid operating system command which has been successfully executed. Failure of sh arises from one of two causes: (i)  The command may have been invalid, in which case the    operating system will print some appropriate    message. (ii) There may have been insufficient memory in which to    execute the command. In general, in such cases, a Fril control error is generated and the goal fails. However, this is dependent on the operating system.</p><h3>Example </h3><pre>The following two programs will delete the files named by a constant bound to FILE, for MS-DOS and UNIX operating systems respectively.<br>((delete_msdos FILE)<br>	(stringof L FILE)<br>	(stringof (d e l ' ' |L) COM)<br>	(sh COM))<br>((delete_unix FILE)<br>	(stringof L FILE)<br>	(stringof (r m ' ' |L) COM) <br>	(sh COM)) </pre><br><h3>See also</h3><p> <h3>Notes</h3> <p> This command is not available on the Macintosh, where there is no concept of a command line. The built-in predicates "remove" and "rename" can be used to delete and rename files respetively on a Macintosh system.<br>The return code of the command is ignored. Memory allocated to Fril execution stacks is released to the operating system before "sh" is invoked. However, memory allocated to the knowledge base is not released to the operating system, even if some procedures are removed using "delcl" or "kill". Such knowledge base space is only made available to new knowledge base items. Thus, when running under MS-DOS, if a large knowledge base has been loaded, "sh" may fail because MS-DOS is unable to allocate core for the command.</p><hr> <a name = "bipsin"> </a><h2>sin  </h2><h3>Usage</h3><p> (sin <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a>) <br></p><h3>Description</h3><p> "sin" checks that <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> is the sine of <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a>, which is assumed to be an angle in radians, or performs the sine or arcsine functional conversion between them.</p><h3> Behaviour </h3><p>Succeeds if both <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> and <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> are numbers and <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> is equal to the sine of <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a>. Alternatively, if either argument is a variable while the other is a number, then the goal is satisfied by performing the appropriate evaluation as follows: If <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> is a variable it is bound to the sine of <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> and if <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> is a variable it is bound to the arcsine of <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a>, where <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> must be in the range -1 to 1. Any other values for the arguments cause the goal to fail.</p><h3>Example </h3><pre>?((sin X 1) (times X 2 PI) (p 'PI' = PI)) <br>PI = 3.14159 <br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipcos">cos</a>, <a href="frilmanual.html#biptan">tan</a><hr> <a name = "bipsnips"> </a><h2>snips  </h2><h3>Usage</h3><p> (snips <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> ... <a href="glossary.html#term" target="gloss">&lt;termn&gt;</a>) <br>i.e. (snips|<a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a>)</p><h3>Description</h3><p> "snips" makes its goal argument deterministic. The meaning of this is as follows: whether or not <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a> is resatisfiable, (snips|<a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a>) is not resatisfiable.</p><h3> Behaviour </h3><p>"snips" succeeds if goal <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a> succeeds, otherwise snips fails. snips is not resatisfiable and so always fails on backtracking. The first time snips is called, (snips|<a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a>) has exactly the same meaning as <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a>. The syntax of snips is similar to that for both "not" and "negg", i.e. the symbol snips is inserted at the front of the list representing the goal <a href="glossary.html#goal" target="gloss">&lt;goal&gt;</a> being called.</p><h3>Example </h3><pre>((append () X X)) <br>((append (H|T) L (H|S)) (append T L S)) <br>?((append X Y (a b)) (p X Y) (pp) (fail)) <br>() (a b) <br>(a) (b) <br>(a b) () <br>no <br>?((snips append X Y (a b)) (p X Y) (pp) (fail)) <br>() (a b)</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bip?"> ? </a>, <a href="frilmanual.html#bip!"> ! </a>, <a href="frilmanual.html#bipif">if</a>, <a href="frilmanual.html#biprepeat">repeat</a><hr> <a name = "bipspy"> </a><h2>spy  </h2><h3>Usage</h3><p> (spy <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>) <br></p><h3>Description</h3><p> "spy" sets a spy point on procedure named <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>. This is used in association with the leap option to give the user control over trace interaction and trace display output in the Fril prolog trace package.</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> names a procedure defined in the knowledge base, i.e. one that is accessible via "dict". "spy" fails otherwise. In particular, "spy" fails if <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> names a system, export or foreign predicate.</p><h3>Example </h3><pre>((goal X)<br>	(subgoal1 X Y)<br>	(subgoal2 Y Z)<br>	(subgoal3 Z))) <br>spy subgoal3 <br>tq ((goal X))<br>(top-level * 1 0) ****** (goal _3) trace ?l <br>>> (goal 1 3 1) ****** (subgoal3 _5) trace ?n <br>>> (goal 1 3 1) SOLVED (subgoal3 <argZ>) <br>(top-level * 1 0) SOLVED (goal <argX>) <br>yes <br>trace of subgoals "subgoal1" and "subgoal2" not displayed.</pre><br><h3>See also</h3><p> <a href="frilmanual.html#biptq">tq</a>, <a href="frilmanual.html#bipnospy">nospy</a>, <a href="frilmanual.html#bipspying">spying</a><hr> <a name = "bipspying"> </a><h2>spying  </h2><h3>Usage</h3><p> (spying <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>) <br></p><h3>Description</h3><p> "spying" checks whether <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> names a spied procedure. This is only useful in the context of the Fril prolog trace package. If <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a variable, "spying" binds it to the name of a procedure and can be resatisfied by binding <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> to different spied procedure names.</p><h3> Behaviour </h3><p>Succeeds when <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> either names a spied procedure (i.e. one on which a spy point has been set using "spy"), or is a variable and there exist procedures with spy points set. </p><h3>Example </h3><pre>Assume that procedures for append, member, reverse and length are defined in the knowledge base. <br>spy append <br>spy reverse <br>?((dict X) (p X "") (fail)) <br>append member reverse length <br>no <br>?((spying X) (p X "") (fail)) <br>append reverse <br>no</pre><br><h3>See also</h3><p> <a href="frilmanual.html#biptq">tq</a>, <a href="frilmanual.html#bipnospy">nospy</a>, <a href="frilmanual.html#bipspy">spy</a><h3>Notes</h3> <p> "spying" is resatisfiable.</p><hr> <a name = "bipsquare"> </a><h2>square  </h2><h3>Usage</h3><p> (square <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a>) <br></p><h3>Description</h3><p> "square" checks that <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> is the square of <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a>, where both arguments are numbers, or performs the square or positive square root functional conversion between them.</p><h3> Behaviour </h3><p>Succeeds if both <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> and <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> are numbers and <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> is equal to the square of <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a>. Alternatively, if either argument is a variable while the other is a number, then the goal is satisfied by performing the appropriate evaluation as follows: If <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> is a variable it is bound to the square of <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> and if <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> is a variable it is bound to the positive square root of <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a>. Any other values for the arguments causes the goal to fail. </p><h3>Example </h3><pre>((root X)<br>	(square Y X)<br>	(times Y -1 Z)<br>	(p The square roots of X are Y and Z)) <br>root 12<br>The square roots of 12 are 3.4641 and -3.4641<br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bippower">power</a>, <a href="frilmanual.html#bipexp">exp</a>, <a href="frilmanual.html#biptimes">times</a><h3>Notes</h3> <p> Like all Fril arithmetic predicates, "square" performs only real arithmetic functions - i.e. it cannot compute the square root of a negative number.</p><hr> <a name = "bipstatistics"> </a><h2>statistics  </h2><h3>Usage</h3><p> (statistics) <br></p><h3>Description</h3><p> "statistics" prints the current space used by each of the five stacks, the knowledge base, and the symbol table. It also prints the time used by the process.</p><h3> Behaviour </h3><p>Always succeeds.</p><h3>Example </h3><pre>?((statistics))<br>control stack : 	226 of 32736 bytes used<br>copy stack : 	384 of 32736 bytes used<br>trail :	8 of 32736 bytes used<br>environment stack : 	32 of 32736 bytes used<br>support stack : 	0 of 32736 bytes used<br>knowledge base : 	155358 of 171864 bytes used<br>symbol table : 	28364 of 36819 bytes used<br>cputime : total 34.25 secs<br>(5.65 since last call)</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipcputime">cputime</a>, <a href="frilmanual.html#bipkb_garbage">kb_garbage</a>, <a href="frilmanual.html#bipsystem_garbage">system_garbage</a>, <a href="frilmanual.html#bipdate">date</a><hr> <a name = "bipstricteq"> </a><h2>stricteq  </h2><h3>Usage</h3><p> (stricteq <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a>) <br></p><h3>Description</h3><p> "stricteq" checks for strict equality of two terms. No unification is carried out, so that if <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> is a variable, stricteq succeeds only if <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> has previously been unified with <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a>. If <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> and <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> are lists, then stricteq succeeds if corresponding elements are strictly equal. Fuzzy sets are considered to be strictly equal if they contain strictly equal element/membership pairs.</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> and <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> refer to the same object.</p><h3>Example </h3><pre>?((stricteq X X)) <br>yes <br>?((stricteq X Y)) <br>no <br>?((eq X Y) (stricteq X Y))<br>yes <br>?((stricteq 'help me' 'help me'))<br>yes <br>?((eq X (a b (c Y)) ) (eq Z Y) (stricteq X (a b (c Z)) )) <br>yes<br>?((stricteq [0:0 1:1 2:0] [0:0 1:1 2:0]))<br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipeq">eq</a>, <a href="frilmanual.html#bipmatch">match</a>, <a href="frilmanual.html#bipposs_match">poss_match</a>, <a href="frilmanual.html#bippoint_match">point_match</a><hr> <a name = "bipstringof"> </a><h2>stringof  </h2><h3>Usage</h3><p> (stringof <a href="glossary.html#list" target="gloss">&lt;list&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>) <br>(stringof <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>)<br>(stringof <a href="glossary.html#list" target="gloss">&lt;list&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>) </p><h3>Description</h3><p>  In the first form of usage, if <a href="glossary.html#list" target="gloss">&lt;list&gt;</a> is bound to a list of constants, each of which is a single character, then <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> will be unified with the corresponding string of those characters. In the second form of usage, if <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> is bound to a string, then <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> is unified with the corresponding list of its individual character constants. In the third form of its usage, both arguments are instantiated.</p><h3> Behaviour </h3><p>Succeeds if the first argument is a list of single character constants and the second argument unifies with the corresponding string of those characters, or if the second argument is a string and the first argument unifies with the corresponding list of individual character constants which make up that string. Otherwise "stringof" fails. </p><h3>Example </h3><pre>?((stringof X Const2) (pq X)) 	%prints ('C' o n s t '2') ?((stringof ('C' 'O' n s t '2') X) (pq X)) 	% prints 'COnst2'</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipcharof">charof</a>, <a href="frilmanual.html#bipname">name</a>,, <a href="frilmanual.html#bipstr_to_list">str_to_list</a><h3>Notes</h3> <p> A number of characters, such as upper case letters and digits, will need to be quoted in the list of individual characters, otherwise stringof will fail.</p><hr> <a name = "bipstr_to_list"> </a><h2>str_to_list  </h2><h3>Usage</h3><p> (str_to_list <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#list" target="gloss">&lt;list&gt;</a>) <br>(str_to_list <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>)<br>(str_to_list <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> <a href="glossary.html#list" target="gloss">&lt;list&gt;</a>)</p><h3>Description</h3><p> The built-in predicate "str_to_list" allows conversion between strings and lists of tokens. In the first two forms the string <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> is broken down into a list of input tokens which is unified with the second argument. Alternatively, in the third usage, the print names of the list elements are concatenated and the result is unified with <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>.</p><h3> Behaviour </h3><p>Succeeds if the first term is a constant whose print name is the list of tokens in the second argument, or when the instantiation of one argument causes this to be true. Otherwise fails.</p><h3>Example </h3><pre>?((str_to_list X (Enter a support for (John likes Jill) ?) (ppq X))<br>‘Enter a support for (John likes Jill) ?’<br>?((str_to_list ‘The quick brown fox’ L) (pp L))<br>(The quick brown fox)</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipstringof">stringof</a>, <a href="frilmanual.html#bipcharof">charof</a>, ask, ask_support, inform, confirm, pose_dialog, set_dlog_val<h3>Notes</h3> <p> This predicate is particularly useful when creating long strings, such as those displayed in dialog boxes. Strings are, of course, subject to the maximum length imposed by Fril (usually 126 characters).</p><hr> <a name = "bipsum"> </a><h2>sum  </h2><h3>Usage</h3><p> (sum <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> <term3>) <br></p><h3>Description</h3><p> "sum" is used to perform addition and subtraction, and succeeds if <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a>+<a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> = <term3>. If two of the arguments are numbers and the third is a variable, the latter is instantiated so that the above relation holds. If the arguments are an itype, a number, and a variable, or two simple itypes and a variable, the variable is instantiated using fuzzy arithmetic. Simple itypes are normalised trapezoidal or triangular itypes, i.e. of the form [a:0 b:1 c:1 d:0] or [a:0 b:1 c:0]</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a>+<a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> = <term3>, or can be made to do so by instantiation of one argument. An error occurs with system reset if: more than one of the terms are variables, more than one of the terms are itypes (other than trapezoidal or triangular), or any of the terms are non-numeric or non-itype.</p><h3>Example </h3><pre> ?((sum 4 3 X) (pp X))<br>7<br>yes<br>?((sum 2 X 3) (pp X))<br>1<br>yes<br>?((sum 2 [0:0 1:1 2:0] X) (pp X))<br>[2:0 3:1 4:0]<br>yes <br>?((sum [1:0 4:1 5:1 6:0] [0:0 1:1 2:0] X) (pp X))<br>[1:0 5:1 6:1 8:0]<br>yes<br>where the last two examples involve fuzzy arithmetic.</pre><br><h3>See also</h3><p> <a href="frilmanual.html#biptimes">times</a><hr> <a name = "bipsupp_collect"> </a><h2>supp_collect  </h2><h3>Usage</h3><p>  <br></p><h3>Description</h3><p> >>> TO BE CONTINUED **</p><h3> Behaviour </h3><p></p><h3>Example </h3><pre>>>> EXAMPLE >>></pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipsc">sc</a>, <a href="frilmanual.html#bipqsc">qsc</a>, <a href="frilmanual.html#biposc">osc</a>, <a href="frilmanual.html#bipwsc">wsc</a>, <a href="frilmanual.html#bip?"> ? </a><hr> <a name = "bipsupp_expect"> </a><h2>supp_expect  </h2><h3>Usage</h3><p>  <br></p><h3>Description</h3><p> >>> TO BE CONTINUED **</p><h3> Behaviour </h3><p></p><h3>Example </h3><pre>>>> EXAMPLE >>></pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipse">se</a>, ose, <a href="frilmanual.html#bipqse">qse</a>, <a href="frilmanual.html#bipwse">wse</a>, <a href="frilmanual.html#bip?"> ? </a>, <a href="frilmanual.html#bipexpected_value">expected_value</a><hr> <a name = "bipsupp_query"> </a><h2>supp_query  </h2><h3>Usage</h3><p> (supp_query <a href="glossary.html#goal_list" target="gloss">goal_list</a> <a href="glossary.html#var_support" target="gloss">&lt;var_support&gt;</a>) <br>(supp_query <a href="glossary.html#goal_list" target="gloss">goal_list</a> <a href="glossary.html#var_support" target="gloss">&lt;var_support&gt;</a> <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>)</p><h3>Description</h3><p> "supp_query" finds the support for each solution to the goal <a href="glossary.html#goal_list" target="gloss">goal_list</a>, binding it to <a href="glossary.html#var_support" target="gloss">&lt;var_support&gt;</a>. The second form of the query allows the semantic unification method to be specified for the query evaluation - this can be "match" (the default), "point_match", or "poss_match". Execution is in breadth-search mode, so that all proof paths are evaluated and the supports combined. It is important that the goal being solved should have a finite search tree, and that all solutions to the goal should be ground (i.e. they should not contain variables or fuzzy sets). This is most easily accomplished by ensuring that all facts used in finding a solution are ground, and that there are no anonymous variables in rules.</p><h3> Behaviour </h3><p>Always succeeds. If <a href="glossary.html#goal_list" target="gloss">goal_list</a> would fail in depth- search execution, supp_query will succeed with a support of (0 1) for the conclusion <a href="glossary.html#goal_list" target="gloss">goal_list</a>.</p><h3>Example </h3><pre>((friends X Y)(likes X Y)(likes Y X)) <br>((likes a b)) : (.9 1) <br>((likes b a)) : (.8 1) <br>?((supp_query ((friends X Y)) S) (p X Y S) (pp) (fail)) <br>a b (0.72 1) <br>b a (0.72 1) <br>no<br>((test [0:0 1:1 2:0]))<br>?((supp_query ((test [.4:0 .9:1 1.2:1 1.6:0])) S)(p S))<br>(0.35 1)<br>yes<br>?((supp_query ((test [.4:0 .9:1 1.2:1 1.6:0])) S point_match)(p S))<br>(0.562786 0.562786)<br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bip?"> ? </a>, <a href="frilmanual.html#bipsupp_value">supp_value</a>, <a href="frilmanual.html#bipsupp_expect">supp_expect</a>, <a href="frilmanual.html#bipsupp_collect">supp_collect</a>, <a href="frilmanual.html#bipqs">qs</a>, <a href="frilmanual.html#bipos">os</a>, <a href="frilmanual.html#bipws">ws</a>, <a href="frilmanual.html#bipand">and</a>, <a href="frilmanual.html#bipor">or</a>, <a href="frilmanual.html#bipnot">not</a>, <a href="frilmanual.html#bipconj">conj</a>, <a href="frilmanual.html#bipdisj">disj</a>, <a href="frilmanual.html#bipmatch">match</a>, <a href="frilmanual.html#bipposs_match">poss_match</a>, <a href="frilmanual.html#bippoint_match">point_match</a>, <a href="frilmanual.html#biptrue">true</a>, <a href="frilmanual.html#bipse">se</a>, <a href="frilmanual.html#bipsc">sc</a>, <a href="frilmanual.html#bipsv">sv</a>, <a href="frilmanual.html#bipgeneral">general</a>  <a href="frilmanual.html#bipevlog">evlog</a><hr> <a name = "bipsupp_value"> </a><h2>supp_value  </h2><h3>Usage</h3><p>  <br></p><h3>Description</h3><p> >>> TO BE CONTINUED **</p><h3> Behaviour </h3><p></p><h3>Example </h3><pre>>>> EXAMPLE >>></pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipsv">sv</a>", <a href="frilmanual.html#bipqsv">qsv</a>, <a href="frilmanual.html#bipwsv">wsv</a>, <a href="frilmanual.html#biposv">osv</a>, <a href="frilmanual.html#bip?"> ? </a><hr> <a name = "bipsv"> </a><h2>sv  </h2><h3>Usage</h3><p>  <br></p><h3>Description</h3><p> >>> TO BE CONTINUED **</p><h3> Behaviour </h3><p></p><h3>Example </h3><pre>>>> EXAMPLE >>></pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsupp_value">supp_value</a> <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipse">se</a>, <a href="frilmanual.html#bipsc">sc</a>, <a href="frilmanual.html#bipqsv">qsv, </a><a href="frilmanual.html#bipwsv">wsv</a>, <a href="frilmanual.html#biposv">osv</a>, <a href="frilmanual.html#bip?"> ? </a><hr> <a name = "bipsys"> </a><h2>sys  </h2><h3>Usage</h3><p> (sys <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>) <br></p><h3>Description</h3><p> "sys" checks whether <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> is the name of a built-in predicate.</p><h3> Behaviour </h3><p>"sys" succeeds when <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> is the name of a built-in predicate, and fails otherwise. </p><h3>Example </h3><pre>sys append <br>no <br>sys times <br>yes <br>sys X <br>no</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipdict">dict</a>, <a href="frilmanual.html#bipcdict">cdict</a>, <a href="frilmanual.html#biprdict">rdict</a>, <a href="frilmanual.html#bipidict">idict</a>, <a href="frilmanual.html#bipddict">ddict</a>, <a href="frilmanual.html#bipmdict">mdict</a>, menudict, <a href="frilmanual.html#bipunivdict">univdict</a>, fdict, <a href="frilmanual.html#bipcl">cl</a><h3>Notes</h3> <p> "sys" can only be used to check, not to generate. This is different to the "dict" family of built-in predicates. Foreign language functions that have been built into Fril using "xfril" do not count as system predicates - they are generated and checked by "fdict".</p><hr> <a name = "bipsystem_garbage"> </a><h2>system_garbage  </h2><h3>Usage</h3><p> (system_garbage)  <br></p><h3>Description</h3><p> "system_garbage" reclaims space that has been used by temporary system items created in the knowledge base. This occurs during execution of the built-in predicates  "supp_expect", "supp_value", "qse", "qsv", "ose", "osv", "wse", "wsv", and "gensym". "system_garbage" kills intermediate predicates, then calls "kb_garbage" to reclaim the space.</p><h3> Behaviour </h3><p>Always succeeds.</p><h3>Example </h3><pre>?((system_garbage))</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipstatistics">statistics</a>, <a href="frilmanual.html#bipkb_garbage">kb_garbage</a><h3>Notes</h3> <p> It is best to avoid using this predicate, or at least only call it from top-level queries, to avoid possible conflicts with embedded calls to the support evaluation predicates.</p><hr> <a name = "biptan"> </a><h2>tan  </h2><h3>Usage</h3><p> (tan <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a>) <br></p><h3>Description</h3><p> "tan" checks that <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> is the tangent of <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a>, which is assumed to be an angle in radians, or performs the tangent or arctangent functional conversion between them.</p><h3> Behaviour </h3><p>Succeeds if both <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> and <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> are numbers and <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> is equal to the tangent of <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a>. Alternatively, if either argument is a variable while the other is a number, then the goal is satisfied by performing the appropriate evaluation as follows: If <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> is a variable it is bound to the tangent of <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> and if <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> is a variable it is bound to the arctangent of <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a>. Any other values for the arguments cause the goal to fail.</p><h3>Example </h3><pre>?((tan X 1) (times X 4 PI) (p 'PI' = PI)) <br>PI = 3.14159 <br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsin">sin</a>, <a href="frilmanual.html#bipcos">cos</a><hr> <a name = "biptempfile"> </a><h2>tempfile  </h2><h3>Usage</h3><p> (tempfile <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>) <br></p><h3>Description</h3><p> "tempfile" generates a unique temporary filename of the form frlXXXXX, where XXXXX is a system-dependent string of characters. If the environment variable FRTEMP is specified, the filename is prefixed with the directory named by FRTEMP. </p><h3> Behaviour </h3><p>Always succeeds.</p><h3>Example </h3><pre>?((tempfile X)(pp X))<br>frl027611</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipexists">exists</a>, file, <a href="frilmanual.html#bipgensym">gensym</a>, <hr> <a name = "biptimes"> </a><h2>times  </h2><h3>Usage</h3><p> (times <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> <term3>) <br></p><h3>Description</h3><p> "times" is used to perform multiplication and division, and succeeds if <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a>*<a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> = <term3>. If two of the arguments are numbers and the third is a variable, the latter is instantiated so that the above relation holds. If the arguments are an itype, a number, and a variable, or two simple itypes and a variable, the variable is instantiated using fuzzy arithmetic. Simple itypes are normalised trapezoidal or triangular itypes, i.e. of the form [a:0 b:1 c:1 d:0] or [a:0 b:1 c:0]</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a>*<a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> = <term3>. </p><h3>Example </h3><pre>?((times 4 3 X) (pp X)) <br>% prints 12 <br>?((times 2 X 3) (pp X)) <br>% prints 1.5 <br>?((times 2 X 3.0) (pp X)) <br>% prints 1.5 <br>?((times 2 [0:0 1:1 2:0] X) (pp X)) <br>% prints [0:0 2:1 4:0]<br>?((times [1:0 4:1 5:1 6:0] [0:0 1:1 2:0] X) (pp X))<br>% prints [0:0 4:1 5:1 12:0]<br>?((times [-1:0 4:1 5:1 6:0] [0:0 1:1 2:0] X) (pp X))<br>% prints [-2:0 4:1 5:1 12:0]<br>% where the last three examples involve fuzzy arithmetic.</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsquare">square</a>, <a href="frilmanual.html#bippower">power</a>, <a href="frilmanual.html#bipsum">sum</a>, <a href="frilmanual.html#bipremainder">remainder</a>, <a href="frilmanual.html#bipdivision">division</a><h3>Notes</h3> <p> Dividing by zero causes a reset error. "times" cannot be used to divide a number by an itype, or to perform arithmetic on more than one itype.</p><hr> <a name = "biptq"> </a><h2>tq  </h2><h3>Usage</h3><p> (tq <a href="glossary.html#goal_list" target="gloss">goal_list</a>) <br>(tq <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>) </p><h3>Description</h3><p>  In the first form, "tq" invokes the Fril prolog tracer on the conjunction of goals in <a href="glossary.html#goal_list" target="gloss">goal_list</a>. "tq" mimics the built-in predicate "?", following exactly the same depth first execution strategy that Fril prolog uses, but it allows users to follow proof path inferences step by step, observing the instantiations of successful goals. The user can interact with the interpreter for goal execution and inference, and can control the amount of trace information that is displayed. In the second form, the user can change trace defaults with <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> set to "setup" or "reset".</p><h3> Behaviour </h3><p>In the non-window trace package, (tq <a href="glossary.html#goal_list" target="gloss">goal_list</a>) succeeds if the goal (? <a href="glossary.html#goal_list" target="gloss">goal_list</a>) would succeed, otherwise it fails. In the window trace package, "tq" always succeeds and the program output and trace display output are presented in different windows</p><h3>Example </h3><pre>((goal X) (subgoal1 X Y) (subgoal2 Y Z) (subgoal3 Z)) <br>((subgoal1 X Y) (p called subgoal1) (eq X Y))<br>tq ((goal hello)) <br></pre><br><pre>(top-level * 1 0) ****** (goal hello) trace ? y<br>(goal 1 1 1) ****** (subgoal1 hello _25d) trace ? n<br>(goal 1 1 1) SOLVED (subgoal1 hello hello)<br>(goal 1 2 1) ****** (subgoal2 hello _25e)<br>(goal 1 2 1) FAILED (subgoal2 hello _25e) - no definition for subgoal2<br>(goal 1 1 1) FAILED (subgoal1 hello _25d)<br>(top-level * 1 0) FAILED (goal hello) - try again (n,y or q) ?n</pre><h3>See also</h3><p> <a href="frilmanual.html#bipspy">spy</a>, <a href="frilmanual.html#bipspying">spying</a>, <a href="frilmanual.html#bipnospy">nospy</a><hr> <a name = "biptrue"> </a><h2>true  </h2><h3>Usage</h3><p> (true <a href="glossary.html#support" target="gloss">&lt;support&gt;</a>) <br></p><h3>Description</h3><p> "true" acts as though it were a goal which succeeded with support pair <a href="glossary.html#support" target="gloss">&lt;support&gt;</a>.</p><h3> Behaviour </h3><p>Always succeeds. Modifies support when system is evaluating supports (this is the only useful context). </p><h3>Example </h3><pre>((high_temp X)<br>	(less 60 X)<br>	(less X 70)<br>	(sum Y 60 X)<br>	(times Z 10.0 Y)<br>	(true (Z Z)))  : ((1 1) (0 0))<br>((high_temp X) (less 70 X)) <br>?((supp_query ((high_temp 65)) S) (pp S)) <br>(0.5 0.5)<br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipmatch">match</a>, <a href="frilmanual.html#bipposs_match">poss_match</a>, <a href="frilmanual.html#bippoint_match">point_match</a>, <a href="frilmanual.html#bipor">or</a>, <a href="frilmanual.html#bipnot">not</a><h3>Notes</h3> <p> A warning message is printed if "true" is used when the system is not evaluating supports.</p><hr> <a name = "biptruncate"> </a><h2>truncate  </h2><h3>Usage</h3><p> (truncate <float> <a href="glossary.html#int" target="gloss">&lt;int&gt;</a>) <br>(truncate <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> <a href="glossary.html#int" target="gloss">&lt;int&gt;</a>)<br>(truncate <float> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>) </p><h3>Description</h3><p>  "truncate" converts integers to floating point numbers and vice-versa.</p><h3> Behaviour </h3><p>"truncate" succeeds if, in the first form, <a href="glossary.html#int" target="gloss">&lt;int&gt;</a> is the largest integer not greater than <float>. In the second form, <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> is instantiated to a floating point number equal to <a href="glossary.html#int" target="gloss">&lt;int&gt;</a>. In the third form, <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> is instantiated to the largest integer not greater than <float>. </p><h3>Example </h3><pre>?((truncate 12.1 X) (int X) (pp X))<br>12<br>yes<br>?((truncate 12.0 12))<br>yes<br>?((truncate Y 12) (pp Y) (int Y))<br>12<br>no<br>?((cprintf stdout "%2.2f" 20))<br>0.00	% incorrect printout because 20 is an integer, not a float <br>?((truncate F20 20)(cprintf stdout "%2.2f" F20))<br>20.00	% correct printout<br></pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipint">int</a>, <a href="frilmanual.html#bipnum">num</a>, <a href="frilmanual.html#bipless">less</a>,, <a href="frilmanual.html#bipremainder">remainder</a>, <a href="frilmanual.html#bipdivision">division</a><h3>Notes</h3> <p> "truncate" is primarily used for rounding a float to the nearest integer. There is very little use for generating floating point numbers from integers, since all arithmetic predicates treat integers and floating point numbers in the same way. It can be useful for presenting arguments to "cprintf".</p><hr> <a name = "bipunion"> </a><h2>union  </h2><h3>Usage</h3><p> (union <a href="glossary.html#fset" target="gloss">&lt;fset1&gt;</a> <a href="glossary.html#fset" target="gloss">&lt;fset2&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>) <br>(union <a href="glossary.html#fset" target="gloss">&lt;fset1&gt;</a> <a href="glossary.html#fset" target="gloss">&lt;fset2&gt;</a> <a href="glossary.html#fset" target="gloss">&lt;fset3&gt;</a>)</p><h3>Description</h3><p> "union" generates or checks the union of two fuzzy sets. In the first form, <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> is bound to the union of the two fuzzy sets <a href="glossary.html#fset" target="gloss">&lt;fset1&gt;</a> and <a href="glossary.html#fset" target="gloss">&lt;fset2&gt;</a>; the second form is used to check that the result of forming the union of fuzzy sets <a href="glossary.html#fset" target="gloss">&lt;fset1&gt;</a> and <a href="glossary.html#fset" target="gloss">&lt;fset2&gt;</a> is <a href="glossary.html#fset" target="gloss">&lt;fset3&gt;</a>.</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#fset" target="gloss">&lt;fset1&gt;</a> and <a href="glossary.html#fset" target="gloss">&lt;fset2&gt;</a> are both discrete or continuous fuzzy sets, and either the third argument is either a variable (which is bound to the union) or a fuzzy set which is identical to the union. Fails otherwise.</p><h3>Example </h3><pre>set (days (Mon Tues Weds Thurs Fri Sat Sun))<br>(weekend {Fri:0.8 Sat:1.0 Sun:1.0 Mon:0.2} days)<br>(itp1 [1:0 2:1 2.5:0])<br><br>?((union [0:0 1:1 2:0] itp1 X)(pp X))<br>[0:0 1:1 1.5:0.5 2:1 3:0]<br>yes<br><br>?((union [10:0 11:1 12:0] itp1 X)(pp X))<br>[1:0 2:1 3:0 10:0 11:1 12:0]<br>yes<br><br>?((union [0:0 1:1 2:0.5 2.5:0] {1:1 2:1 3:1} X)(pp X))<br>no<br><br>?((union weekend {Thurs:0.8 Fri:1} X) (pp X))<br>{Fri:1 Sat:1 Sun:1 Thurs:0.8 Mon:0.2}<br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipintersection">intersection</a>, <a href="frilmanual.html#bipcomplement">complement</a>, <a href="frilmanual.html#bipset_difference">set_difference</a>, <a href="frilmanual.html#bipitype">itype</a>, <a href="frilmanual.html#bipdtype">dtype</a>, <a href="frilmanual.html#bipset">set</a>, <a href="frilmanual.html#bipuniv">univ</a>, <a href="frilmanual.html#bipitype_to_list">itype_to_list</a>, <a href="frilmanual.html#bipdtype_to_list">dtype_to_list</a><h3>Notes</h3> <p> It is not possible to find the union of a dtype fuzzy set and an itype fuzzy set, since this operatione could lead to an itype fuzzy set with discontinuities in its membership function.</p><hr> <a name = "bipuniv"> </a><h2>univ  </h2><h3>Usage</h3><p> (univ <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>) <br></p><h3>Description</h3><p> "univ" checks whether <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> names a defined universe for fuzzy sets. The universe may be continuous or discrete.</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> names a defined universe for fuzzy set, fails otherwise.</p><h3>Example </h3><pre>set (days (Mon Tues Weds Thurs Fri Sat Sun))<br>set (sizes 0 100)<br>set (positives 0 pos_inf)<br>(small_size [0:0 10:1 20:1 30:0] sizes)<br>(weekend {Fri:0.8 Sat:1.0 Sun:1.0 Mon:0.2} days)<br>The following queries succeed:<br>	univ days<br>	univ sizes<br>	univ positives<br>whilst the following fail:<br>	univ small_size<br>	univ weekend<br>	univ fred</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipcon">con</a>, <a href="frilmanual.html#bipnum">num</a>, <a href="frilmanual.html#bipint">int</a>, <a href="frilmanual.html#bipitype">itype</a>, <a href="frilmanual.html#bipdtype">dtype</a>, <a href="frilmanual.html#bipfset">fset</a>, <a href="frilmanual.html#bipatomic">atomic</a>, <a href="frilmanual.html#bipvar">var</a>, <a href="frilmanual.html#bipunivdict">univdict</a>, <a href="frilmanual.html#bipuniv_name">univ_name</a>, <a href="frilmanual.html#bipset">set</a>, <a href="frilmanual.html#bipget_univ">get_univ</a><hr> <a name = "bipunivdict"> </a><h2>univdict  </h2><h3>Usage</h3><p> (univdict <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>) <br></p><h3>Description</h3><p> "univdict" is used to check whether <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a universe for fuzzy sets, or to generate names of universes defined in the knowledge base.</p><h3> Behaviour </h3><p>Succeeds if <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a universe defined in the knowledge base. If <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a variable, Fril will bind it to a universe (if any are defined), and will resatisfy the call if necessary.</p><h3>Example </h3><pre>set (days (Mon Tues Weds Thurs Fri Sat Sun))<br>set (sizes 0 100)<br>set (positives 0 pos_inf)<br>(small_size [0:0 10:1 20:1 30:0] sizes)<br>(weekend {Fri:0.8 Sat:1.0 Sun:1.0 Mon:0.2} days)<br>univdict days<br>yes<br>univdict sizes<br>yes<br>univdict small_size<br>no<br>?((univdict X) (pq X represented internally as)(p)(pp X) (fail))<br>positives represented internally as [-0.0001:0 0:1]<br>sizes represented internally as [-0.01:0 0:1 100:1 100.01:0]<br>days represented internally as {Fri:1 Sat:1 Sun:1 Thurs:1 Weds:1 Tues:1 Mon:1}</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipset">set</a>, <a href="frilmanual.html#bipidict">idict</a>, <a href="frilmanual.html#bipddict">ddict</a>, <a href="frilmanual.html#bipfsetdict">fsetdict</a>, <a href="frilmanual.html#bipuniv">univ</a>, <a href="frilmanual.html#bipuniv_name">univ_name</a>, <a href="frilmanual.html#bipsys">sys</a>, <a href="frilmanual.html#bipdict">dict</a>, <a href="frilmanual.html#bipget_univ">get_univ</a>, <a href="frilmanual.html#bipget_prior">get_prior</a><hr> <a name = "bipuniv_name"> </a><h2>univ_name  </h2><h3>Usage</h3><p> (univ_name <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> <a href="glossary.html#univ" target="gloss">&lt;univ&gt;</a>) <br>(univ_name <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#var" target="gloss">&lt;var&gt;</a>)<br>(univ_name <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#univ" target="gloss">&lt;univ&gt;</a>)</p><h3>Description</h3><p> "univ_name" converts a constant into the universe named by that constant, and vice-versa. It can also be used to check that a constant names a given universe The first form binds <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> to the name of the universe <a href="glossary.html#univ" target="gloss">&lt;univ&gt;</a>. The second form binds <a href="glossary.html#var" target="gloss">&lt;var&gt;</a> to the definition of the universe named by <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>. The third form checks that <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> is the name of the universe <a href="glossary.html#univ" target="gloss">&lt;univ&gt;</a>.</p><h3> Behaviour </h3><p>Succeeds if the first argument names the universe given by the second argument, or if one argument can be instantiated to make this so.</p><h3>Example </h3><pre>set ('exam percentage' 0 100)<br>('good mark' [65:0 80:1] 'exam percentage')<br>?((get_univ 'good mark' U) (pq 'good mark' is a subset of U))<br>'good mark' is a subset of 'exam percentage'<br>yes<br>?((get_univ 'good mark' U) <br>	(itype_name GNAME 'good mark')<br>	(univ_name UNAME U)<br>	(p GNAME is a subset of UNAME))<br>good mark is a subset of exam percentage<br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipuniv">univ</a>, <a href="frilmanual.html#bipunivdict">univdict</a>, <a href="frilmanual.html#bipitype_name">itype_name</a>, <a href="frilmanual.html#bipdtype_name">dtype_name</a>, <a href="frilmanual.html#bipfset_name">fset_name</a>, <a href="frilmanual.html#bipget_univ">get_univ</a><h3>Notes</h3> <p> The second and third forms require the actual name of the universe. Since Fril replaces all occurrences of a universe name by the universe definition, the constant is only available from built-in predicates which create symbols (e.g. name, univ_name, dtype_name, itype_name, fset_name) or from input which is read prior to the definition of the universe.</p><hr> <a name = "bipvar"> </a><h2>var  </h2><h3>Usage</h3><p> (var <a href="glossary.html#term" target="gloss">&lt;term&gt;</a>) <br></p><h3>Description</h3><p> "var" tests whether its argument is an uninstantiated variable.</p><h3> Behaviour </h3><p>Succeeds when <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> is a variable, fails otherwise.</p><h3>Example </h3><pre>((check X) (var X) (p term X is a variable)) <br>((check X) (num X) (p term X is a number)) .<br>.. etc.<br>check HIM<br>term _4 is a variable<br>check 12<br>term 12 is a number </pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipcon">con</a>, <a href="frilmanual.html#bipint">int</a>, <a href="frilmanual.html#bipnum">num</a>, <a href="frilmanual.html#bipitype">itype</a>, <a href="frilmanual.html#bipdtype">dtype</a>, <a href="frilmanual.html#bipuniv">univ</a>, <a href="frilmanual.html#bipfset">fset</a>, <a href="frilmanual.html#bipatomic">atomic</a><hr> <a name = "bipvisible"> </a><h2>visible  </h2><h3>Usage</h3><p> (visible <a href="glossary.html#const" target="gloss">&lt;const&gt;</a>) <br>(visible (<a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> ... <a href="glossary.html#const" target="gloss">&lt;constn&gt;</a>))</p><h3>Description</h3><p> This predicate is only relevant in the context of the construction of a module. "visible" is used to declare as visible, predicate name <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> in the first form, or each of the predicates <a href="glossary.html#const" target="gloss">&lt;const1&gt;</a> to <a href="glossary.html#const" target="gloss">&lt;constn&gt;</a> in the second form. This is necessary when they (or it) are to be called by a meta-call from within the same module. Meta-calls will otherwise only be able to make calls to the user accessible predicates. In terms of user accessibility, visible predicates are bound by the same rules and behave in the same way as export predicates.</p><h3> Behaviour </h3><p>Always succeeds. No effect except in a source file when compiled by the module compiler.</p><h3>Example </h3><pre>(see module example)</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipmodule">module</a>,, <a href="frilmanual.html#bipexport">export</a>, <a href="frilmanual.html#bipimport">import</a>, <a href="frilmanual.html#bipdynamic">dynamic</a>, <a href="frilmanual.html#bipedict">edict</a>, <a href="frilmanual.html#bipmdict">mdict</a>, <a href="frilmanual.html#bipkill">kill</a><h3>Notes</h3> <p> By declaring a predicate "visible", so that it can be called from a meta-call, the predicate is made user accessible and should therefore be treated exactly as an "export" predicate. It will appear in the export dictionary, accessed by "edict", and must not be allowed to clash with the name of other knowledge base procedures and exports. The importance of the distinction is that "visible" predicates are intended to be called from the same module, whereas "export" predicates are intended to be called from the knowledge base and other modules.</p><hr> <a name = "bipw"> </a><h2>w  </h2><h3>Usage</h3><p> (w <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> . . . <a href="glossary.html#term" target="gloss">&lt;termn&gt;</a>) <br></p><h3>Description</h3><p> "w" prints its arguments, separated by spaces, on the output stream <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a>. The next print operation on <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a> commences immediately after the last term printed. (w <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a>) with no other arguments prints a single space on the stream. Strings are printed without quotes, and fuzzy sets appear as itype or dtype definitions.</p><h3> Behaviour </h3><p>Always succeeds. </p><h3>Example </h3><pre>?((create fred) (w fred 'hello fred') (close fred)) <br>would leave the file fred containing a single line: <br>hello fred</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipwq">wq</a>, <a href="frilmanual.html#bipwrite">write</a>, <a href="frilmanual.html#bipwriteq">writeq</a>, <a href="frilmanual.html#bipp">p</a>, <a href="frilmanual.html#bipcprintf">cprintf</a>, <a href="frilmanual.html#bipwspaces">wspaces</a>, <a href="frilmanual.html#bipputb">putb</a>, <a href="frilmanual.html#bipcreate">create</a><h3>Notes</h3> <p> <a href="glossary.html#out_stream">&lt;out_stream&gt;</a> must be a pre-defined output stream (stdout, stderr), or have been opened using "create" or a related built-in predicate.</p><hr> <a name = "bipwh"> </a><h2>wh  </h2><h3>Usage</h3><p> (wh (<a href="glossary.html#term" target="gloss">&lt;term&gt;</a> <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> ... <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a>)) <br>i.e. (wh (<a href="glossary.html#term" target="gloss">&lt;term&gt;</a>|<a href="glossary.html#goal_list" target="gloss">goal_list</a>))</p><h3>Description</h3><p> "wh" executes the series of calls in <a href="glossary.html#goal_list" target="gloss">goal_list</a> using the standard depth-first search mechanism, and prints the corresponding instantiations of <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> for which <a href="glossary.html#goal_list" target="gloss">goal_list</a> succeeds, at the standard output. "wh" backtracks to find all possible solutions without any further interaction from the user and finally succeeds printing a completion message, whether or not any solutions were found.</p><h3> Behaviour </h3><p>"wh" always succeeds provided its argument is valid. If there is no solution to the query it simply prints the message "no (more) solutions" and succeeds. Otherwise "wh" prints the <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> corresponding to each successfully instantiated query pattern one after the other until no more solutions can be found when the message "no (more) solutions" is printed and "wh" succeeds.</p><h3>Example </h3><pre>Using standard definitions for "append" and "length":<br>wh ((X has length N) (append X Y (a b c)) (length X N)) <br>(() has length 0) <br>((a) has length 1) <br>((a b) has length 2) <br>((a b c) has length 3) <br>no (more) solutions <br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bip?"> ? </a>, <a href="frilmanual.html#bipoh">oh</a>, <a href="frilmanual.html#bipqh">qh</a>, <a href="frilmanual.html#bipws">ws</a><hr> <a name = "bipwq"> </a><h2>wq  </h2><h3>Usage</h3><p> (wq <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term2&gt;</a> .... <a href="glossary.html#term" target="gloss">&lt;termn&gt;</a>) <br></p><h3>Description</h3><p> "wq" prints its arguments, separated by spaces, on the output stream <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a>. The next print operation on <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a> commences immediately after the last term printed. (w <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a>) with no other arguments prints a single space on the stream. Strings are printed with quotes if necessary, and a named fuzzy set appears as the name, rather than the definition.</p><h3> Behaviour </h3><p>Always succeeds. </p><h3>Example </h3><pre>?((create fred) (wq fred 'hello fred') (close fred)) <br>would leave the file fred containing the string <br>'hello fred'</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipw">w</a>, <a href="frilmanual.html#bipwrite">write</a>, <a href="frilmanual.html#bipwriteq">writeq</a>, <a href="frilmanual.html#bippq">pq</a>, <a href="frilmanual.html#bipcprintf">cprintf</a>, <a href="frilmanual.html#bipwspaces">wspaces</a>, <a href="frilmanual.html#bipputb">putb</a>, <a href="frilmanual.html#bipcreate">create</a><h3>Notes</h3> <p> <a href="glossary.html#out_stream">&lt;out_stream&gt;</a> must be a pre-defined output stream (stdout, stderr), or have been opened using "create" or a related built-in predicate.</p><hr> <a name = "bipwrite"> </a><h2>write  </h2><h3>Usage</h3><p> (write <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> ... <a href="glossary.html#term" target="gloss">&lt;termn&gt;</a>) <br></p><h3>Description</h3><p> "write" prints each term followed by a new line on the output stream <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a>. The goal (write <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a>) with no other arguments prints a new line on the stream. Strings are printed without quotes, and fuzzy sets appear as itype or dtype definitions.</p><h3> Behaviour </h3><p>Always succeeds.</p><h3>Example </h3><pre>?((create fred) (write fred hello fred) (close fred)) <br>would leave the file fred containing the following two lines:<br>hello <br>fred</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipw">w</a>, <a href="frilmanual.html#bipwq">wq</a>, <a href="frilmanual.html#bipwriteq">writeq</a>, <a href="frilmanual.html#bippp">pp</a>, <a href="frilmanual.html#bipcprintf">cprintf</a>, <a href="frilmanual.html#bipwspaces">wspaces</a>, <a href="frilmanual.html#bipputb">putb</a>, <a href="frilmanual.html#bipcreate">create</a><h3>Notes</h3> <p> <a href="glossary.html#out_stream">&lt;out_stream&gt;</a> must be a pre-defined output stream (stdout, stderr), or have been opened using "create" or a related built-in predicate.</p><hr> <a name = "bipwriteq"> </a><h2>writeq  </h2><h3>Usage</h3><p> (writeq <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term1&gt;</a> ... <a href="glossary.html#term" target="gloss">&lt;termn&gt;</a>) <br></p><h3>Description</h3><p> "writeq" prints each term followed by a new line on the output stream <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a>. Goal (writeq <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a>) with no other arguments prints a new line on the stream. Strings are printed with quotes if necessary, and a named fuzzy set appears as the name, rather than the definition.</p><h3> Behaviour </h3><p>Always succeeds.</p><h3>Example </h3><pre>?((create fred) (writeq fred 'HELLO' fred) (close fred)) <br>would leave the file fred containing the following two lines: <br>'HELLO' <br>fred</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipw">w</a>, <a href="frilmanual.html#bipwq">wq</a>, <a href="frilmanual.html#bipwrite">write</a>, <a href="frilmanual.html#bipppq">ppq</a>, <a href="frilmanual.html#bipcprintf">cprintf</a>, <a href="frilmanual.html#bipwspaces">wspaces</a>, <a href="frilmanual.html#bipputb">putb</a>, <a href="frilmanual.html#bipcreate">create</a><h3>Notes</h3> <p> <a href="glossary.html#out_stream">&lt;out_stream&gt;</a> must be a pre-defined output stream (stdout, stderr), or have been opened using "create" or a related built-in predicate.</p><hr> <a name = "bipws"> </a><h2>ws  </h2><h3>Usage</h3><p> (ws (<a href="glossary.html#term" target="gloss">&lt;term&gt;</a> <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> ... <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a>)) <br>i.e. (ws (<a href="glossary.html#term" target="gloss">&lt;term&gt;</a>|<a href="glossary.html#goal_list" target="gloss">goal_list</a>))<br>(ws (<a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> ... <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a>))</p><h3>Description</h3><p>  "ws" finds the support for the conjunction of goals in <a href="glossary.html#goal_list" target="gloss">goal_list</a> for all possible instances of <a href="glossary.html#goal_list" target="gloss">goal_list</a>. "ws" uses "supp_query" for support evaluation so that for each possible instantiation of <a href="glossary.html#goal_list" target="gloss">goal_list</a> all proof paths are evaluated and the supports combined. The second form of the query allows the semantic unification method to be specified for the query evaluation - <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> can be "match" (the default), "point_match", or "poss_match". "ws" backtracks to find all possible solutions, and for each solution found, the corresponding instantiations of <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> together with the solution's computed support are printed at the standard output. "ws" finally succeeds printing a completion message.</p><h3> Behaviour </h3><p>"ws" always succeeds provided its argument is valid. "ws" prints the <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> and support pair corresponding to each successfully instantiated query pattern, until no more solutions can be found when the message "no (more) solutions" is printed and "ws" succeeds.</p><h3>Example </h3><pre>((test a)) : (0.5 0.8) <br>((test b)) : (0.7 0.9) <br>((fuzzy [0:0 1:1 2:0]))<br>ws ((support for X Y) (test X) (test Y)) <br>(support for a a) : (0.25 0.64) <br>(support for a b) : (0.35 0.72) <br>(support for b a) : (0.35 0.72) <br>(support for b b) : (0.49 0.81) <br>no (more) solutions <br>yes<br>ws((support using match)(test [.4:0 .9:1 1.2:1 1.6:0]))<br>(test support using match) : (0.35 1)<br>yes<br>ws(point_match (support using point_match)(test [.4:0 .9:1 1.2:1 1.6:0]))<br>(test support using match) : (0.562786 0.562786)<br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipos">os</a>, <a href="frilmanual.html#bipqs">qs</a>, <a href="frilmanual.html#bipwse">wse</a>, <a href="frilmanual.html#bipwsc">wsc</a>, <a href="frilmanual.html#bipwsv">wsv</a>, <a href="frilmanual.html#bipwh">wh</a><h3>Notes</h3> <p> Although it is possible to backtrack over <a href="glossary.html#goal_list">goal_list</a> for more solutions from within the "ws" goal, "ws" itself is not resatisfiable.</p><hr> <a name = "bipwse"> </a><h2>wse  </h2><h3>Usage</h3><p> (wse (<a href="glossary.html#term" target="gloss">&lt;term&gt;</a> <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> ... <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a>)) <br>i.e. (wse (<a href="glossary.html#term" target="gloss">&lt;term&gt;</a>|<a href="glossary.html#goal_list" target="gloss">goal_list</a>))<br>(wse (<a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> ... <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a>))</p><h3>Description</h3><p>  "wse" finds the support for the conjunction of goals in <a href="glossary.html#goal_list" target="gloss">goal_list</a> for all possible instances of <a href="glossary.html#goal_list" target="gloss">goal_list</a>. "ws" uses "supp_expect" for support evaluation so that for each possible instantiation of <a href="glossary.html#goal_list" target="gloss">goal_list</a> all proof paths are evaluated and the supports combined. Any fuzzy sets in the same argument position in <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> . . . <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a> are combined into a single expected fuzzy set. The second form of the query allows the semantic unification method to be specified for the query evaluation - <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> can be "match" (the default), "point_match", or "poss_match". "wse" backtracks to find all possible solutions, and for each solution found, the corresponding instantiations of <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> together with the solution's computed support are printed at the standard output. "wse" finally succeeds printing a completion message.</p><h3> Behaviour </h3><p>"wse" always succeeds provided its argument is valid. "wse" prints the <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> and support pair corresponding to each successfully instantiated query pattern, until no more solutions can be found when the message "no (more) solutions" is printed and "wse" succeeds.</p><h3>Example </h3><pre>>>> EXAMPLE >>></pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipsupp_expect">supp_expect</a>, <a href="frilmanual.html#bipexpected_value">expected_value</a>, ose, <a href="frilmanual.html#bipqse">qse</a>, <a href="frilmanual.html#bipwh">wh</a>, <a href="frilmanual.html#bipws">ws</a>, <a href="frilmanual.html#bipwsv">wsv</a>, <a href="frilmanual.html#bipwsc">wsc</a><h3>Notes</h3> <p> Although it is possible to backtrack over <a href="glossary.html#goal_list">goal_list</a> for more solutions from within the "wse" goal, "wse" itself is not resatisfiable.</p><hr> <a name = "bipwsc"> </a><h2>wsc  </h2><h3>Usage</h3><p> (wsc (<a href="glossary.html#term" target="gloss">&lt;term&gt;</a> <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> ... <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a>)) <br>i.e. (wsc (<a href="glossary.html#term" target="gloss">&lt;term&gt;</a>|<a href="glossary.html#goal_list" target="gloss">goal_list</a>))<br>(wsc (<a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> ... <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a>))</p><h3>Description</h3><p>  "wsc" finds the support for the conjunction of goals in <a href="glossary.html#goal_list" target="gloss">goal_list</a> for all possible instances of <a href="glossary.html#goal_list" target="gloss">goal_list</a>. "wsc" uses "supp_value" for support evaluation so that for each possible instantiation of <a href="glossary.html#goal_list" target="gloss">goal_list</a> all proof paths are evaluated and the supports combined. Any fuzzy sets in the same argument position in <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> . . . <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a> are combined into a single expected fuzzy set. The second form of the query allows the semantic unification method to be specified for the query evaluation - <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> can be "match" (the default), "point_match", or "poss_match". "wsc" backtracks to find all possible solutions, and for each solution found, the corresponding instantiations of <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> together with the solution's computed support are printed at the standard output. "wsc" finally succeeds printing a completion message.</p><h3> Behaviour </h3><p>"wsc" always succeeds provided its argument is valid. "wse" prints the <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> and support pair corresponding to each successfully instantiated query pattern, until no more solutions can be found when the message "no (more) solutions" is printed and "wsc" succeeds.</p><h3>Example </h3><pre>>>> EXAMPLE >>></pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipsupp_collect">supp_collect</a>, <a href="frilmanual.html#biposc">osc</a>, <a href="frilmanual.html#bipqsc">qsc</a>, <a href="frilmanual.html#bipwh">wh</a>, <a href="frilmanual.html#bipws">ws</a>, <a href="frilmanual.html#bipwse">wse</a>, <a href="frilmanual.html#bipwsv">wsv</a><h3>Notes</h3> <p> Although it is possible to backtrack over <a href="glossary.html#goal_list">goal_list</a> for more solutions from within the "wsc" goal, "wsc" itself is not resatisfiable.</p><hr> <a name = "bipwspaces"> </a><h2>wspaces  </h2><h3>Usage</h3><p> (wspaces <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a> <a href="glossary.html#nni" target="gloss">&lt;nni&gt;</a>) <br></p><h3>Description</h3><p> "wspaces" prints <a href="glossary.html#nni" target="gloss">&lt;nni&gt;</a> spaces on the output stream <a href="glossary.html#out_stream" target="gloss">&lt;out_stream&gt;</a>, where <a href="glossary.html#nni" target="gloss">&lt;nni&gt;</a> is a non-negative integer.</p><h3> Behaviour </h3><p>"wspaces" succeeds if <a href="glossary.html#nni" target="gloss">&lt;nni&gt;</a> is zero or a larger integer, otherwise it fails. </p><h3>Example </h3><pre>?((p start) (wspaces stdout 11) (p finish)) <br>start           finish <br>yes</pre><br><h3>See also</h3><p> <a href="frilmanual.html#bippspaces">pspaces</a>, <a href="frilmanual.html#bipw">w</a>, <a href="frilmanual.html#bipwq">wq</a>, <a href="frilmanual.html#bipwrite">write</a>, <a href="frilmanual.html#bipwriteq">writeq</a>, <a href="frilmanual.html#bipcprintf">cprintf</a><h3>Notes</h3> <p> "wspaces" performs the function that many prolog systems name "tab". However, the name "wspaces" better reflects its intended function.</p><hr> <a name = "bipwsv"> </a><h2>wsv  </h2><h3>Usage</h3><p> (wsv(<a href="glossary.html#term" target="gloss">&lt;term&gt;</a> <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> ... <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a>)) <br>i.e. (wsv(<a href="glossary.html#term" target="gloss">&lt;term&gt;</a>|<a href="glossary.html#goal_list" target="gloss">goal_list</a>))<br>(wsv(<a href="glossary.html#const" target="gloss">&lt;const&gt;</a> <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> ... <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a>))</p><h3>Description</h3><p>  "wsv" finds the support for the conjunction of goals in <a href="glossary.html#goal_list" target="gloss">goal_list</a> for all possible instances of <a href="glossary.html#goal_list" target="gloss">goal_list</a>. "wsv" uses the built-in predicate "supp_value" for support evaluation so that for each possible instantiation of <a href="glossary.html#goal_list" target="gloss">goal_list</a> all proof paths are evaluated and the supports combined. Any fuzzy sets in the same argument position in <a href="glossary.html#goal" target="gloss">&lt;goal1&gt;</a> . . . <a href="glossary.html#goal" target="gloss">&lt;goaln&gt;</a> are combined into a single expected fuzzy set and then defuzzified to give a single value. The second form of the query allows the semantic unification method to be specified for the query evaluation - <a href="glossary.html#const" target="gloss">&lt;const&gt;</a> can be "match" (the default), "point_match", or "poss_match". "wsv" backtracks to find all possible solutions, and for each solution found, the corresponding instantiations of <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> together with the solution's computed support are printed at the standard output. "wsv" finally succeeds printing a completion message.</p><h3> Behaviour </h3><p>"wsv" always succeeds provided its argument is valid. "wsv" prints the <a href="glossary.html#term" target="gloss">&lt;term&gt;</a> and support pair corresponding to each successfully instantiated and defuzzified query pattern, until no more solutions can be found when the message "no (more) solutions" is printed and "wsv" succeeds.</p><h3>Example </h3><pre>((fuzzy [0:0 1:1 2:0]))<br>ws ((support for X Y) (test X) (test Y)) <br>(support for a a) : (0.25 0.64) <br>(support for a b) : (0.35 0.72) <br>(support for b a) : (0.35 0.72) <br>(support for b b) : (0.49 0.81) <br>no (more) solutions <br>yes<br>ws((support using match)(test [.4:0 .9:1 1.2:1 1.6:0]))<br>(test support using match) : (0.35 1)<br>yes<br>ws(point_match (support using point_match)(test [.4:0 .9:1 1.2:1 1.6:0]))<br>(test support using match) : (0.562786 0.562786)<br>yes<br>>>> EXAMPLE >>></pre><br><h3>See also</h3><p> <a href="frilmanual.html#bipsupp_query">supp_query</a>, <a href="frilmanual.html#bipsupp_value">supp_value</a>, <a href="frilmanual.html#biposv">osv</a>, <a href="frilmanual.html#bipqsv">qsv</a>, <a href="frilmanual.html#bipwh">wh</a>, <a href="frilmanual.html#bipws">ws</a>, <a href="frilmanual.html#bipwse">wse</a>, <a href="frilmanual.html#bipwsc">wsc</a><h3>Notes</h3> <p> Although it is possible to backtrack over <a href="glossary.html#goal_list">goal_list</a> for more solutions from within the "wsv" goal, "wsv" itself is not resatisfiable.</p><hr> </body></html>